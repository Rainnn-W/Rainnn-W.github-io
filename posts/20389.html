<!-- build time:Wed Oct 04 2023 14:57:11 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Rainnnの" href="https://rainnn-w.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Rainnnの" href="https://rainnn-w.github.io/atom.xml"><link rel="alternate" type="application/json" title="Rainnnの" href="https://rainnn-w.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="c++"><link rel="canonical" href="https://rainnn-w.github.io/posts/20389.html"><title>C++ Notes | Yume Shoka = Rainnnの = Individual blog</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">C++ Notes</h1><div class="meta"><span class="item" title="Created: 2023-06-21 23:02:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2023-06-21T23:02:00+08:00">2023-06-21</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Yume Shoka</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giciuja1j1j20zk0m8kjl.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gicitf0kl1j20zk0m87fe.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclj9410cj20zk0m8h12.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipewkhf1zj20zk0m81kx.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclize41wj20zk0m87gk.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giph4fomxoj20zk0m8axp.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="CN"><link itemprop="mainEntityOfPage" href="https://rainnn-w.github.io/posts/20389.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Rainnn-W"><meta itemprop="description" content="Individual blog, blingbling~"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Rainnnの"></span><div class="body md" itemprop="articleBody"><h1 id="c"><a class="anchor" href="#c">#</a> C++</h1><h2 id="零-碎"><a class="anchor" href="#零-碎">#</a> 零、碎</h2><h3 id="1选择-判断-知识点"><a class="anchor" href="#1选择-判断-知识点">#</a> 1. 选择 判断 知识点</h3><p>1. 逻辑运算符两侧运算对象的数据类型可以是任何类型的数据</p><p>2. <code>if (!x)</code> 等价于 <code>if (x==0||x=='0')；</code></p><p>3. <code>x = ++y</code> <code>++x =y</code> 是正确的 <code>(x+y)++</code> 是错误的</p><p>4. 条件编译允许在编译时包含不同的代码</p><p>5.C++ 中，cin 是预定义的对象</p><p>6. 使用提取符 (&lt;&lt;) 可以输出各种基本数据类型的变量的值，也可以输出指针值。</p><p>7. 和指针类似，引用被初始化后，还可以引用别的变量。❌</p><p>8. 以下程序中，new 语句干了什么。</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int** num;
num &#x3D; new int* [20];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><p>分配了长度为 20 的整数指针数组空间，并将 num [0] 的指针返回。</p><p>9.c++ 中不允许嵌套函数（在一个函数中定义新函数）</p><p>10. 抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出；</p><p>11. 类的非静态成员函数才有 this 指针</p><p>12.<strong> 因为静态成员函数不能是虚函数</strong>，所以它们不能实现多态。</p><p>13. <code>int i; int &amp;ri=i;</code> 对于这条语句，ri 和 i 这两个变量代表的是同一个存储空间。 （引用）</p><p>14. 构造函数可以被重载，<strong>析构函数不可以被重载</strong>。因为构造函数可以有多个且可以带参数，而析构函数只能有一个，且不能带参数。</p><p>15. 如果基类声明了带有形参表的构造函数，则派生类就应当声明构造函数</p><p>16. 基类中的私有成员不论通过何种派生方式，到了派生类中均变成不可直接访问成员。</p><p>17. 纯虚函数与函数体为空的虚函数等价。❌</p><p>18. 不可以对数组类型进行整体赋值</p><p>19. 函数可以返回一个不带索引的数组名</p><p>20.&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3JhaW5ubi13L1BpY3R1cmVzQG1haW4vYmxvZy8yMDIzMDgyODExMDg3NjAucG5n">https://cdn.jsdelivr.net/gh/rainnn-w/Pictures@main/blog/202308281108760.png</span>&quot; alt=&quot;image-20230615162748030&quot; /&gt;（B）</p><p>21.&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3JhaW5ubi13L1BpY3R1cmVzQG1haW4vYmxvZy8yMDIzMDgyODExMDg1NzcucG5n">https://cdn.jsdelivr.net/gh/rainnn-w/Pictures@main/blog/202308281108577.png</span>&quot; alt=&quot;image-20230615171122503&quot; /&gt;（B）</p><p>22. 指向函数的指针变量 p 可以先后指向不同的同种类型的函数，但不可作加减运算。</p><p>23. 数组名就是数组的起始地址，数组的指针就是数组的起始地址。</p><p>24. 用指针变量作函数参数，可以得到多个变化了的值。</p><p>25. 成员函数是公有的，在内存中存在一份，各个对象都可以使用</p><h3 id="2读程序-计算"><a class="anchor" href="#2读程序-计算">#</a> 2. 读程序 计算</h3><p>（1）</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;若
#define N 3
#define Y(n) ((N+1)*n) 
&#x2F;&#x2F;则
z&#x3D;2*（N+Y(5+1)）&#x2F;&#x2F;z值为<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><blockquote><p>48</p></blockquote><p>（2）负数对正数取余结果为负数，正数对负数取余结果为正数</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">-7%5&#x3D;-2；
7%-5&#x3D;2；
-7%-5&#x3D;-2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><p>（3）运算符优先级</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int x&#x3D;3,y&#x3D;4,z;  
z&#x3D;x++&#x3D;&#x3D;4 || ++y&#x3D;&#x3D;5;  
cout&lt;&lt;y&lt;&lt;z;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><blockquote><p>51</p></blockquote><p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int a&#x3D;0;
cout &lt;&lt; (a&#x3D;4+5,a+5),a+25;
cout &lt;&lt; ((a&#x3D;4+5,a+5),a+25);
cout &lt;&lt; (a&#x3D;3*5,a*4),a+15;
cout &lt;&lt; ((a&#x3D;3*5,a*4),a+15);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><blockquote><p>14346030</p><p>运算符优先级：括号运算 &gt; 加法 &gt; 赋值 &gt; 逗号</p></blockquote><p>（4）条件运算符</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a &#x3D; 1, b &#x3D; 2, c &#x3D; 3, d &#x3D; 4;
int answer &#x3D; a &lt; b ? a : b &lt; c ? b : c &lt; d ? c : d;
cout &lt;&lt; answer;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><blockquote><p>1</p><p>条件运算符的结合性是从右到左结合的，先算 c＜d？c:d 返回 c=3；再算 a＜b？a:c 返回值为 1。</p></blockquote><p>（5）注意细节！</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;执行以下的程序片段，将输出几个数字？
for(i&#x3D;0;i&lt;3;i++);

       cout&lt;&lt;i;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><blockquote><p>1 个数字，for 循环没有方法体</p><p>输出：2</p></blockquote><p>（6） <code>bool</code></p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool flag &#x3D; 2021;&#x2F;&#x2F;flag 1
cout &lt;&lt; (flag &gt; 2019) + flag * 2 + bool(4) &lt;&lt; endl; &#x2F;&#x2F;输出结果为3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><p>（7）string</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char s[5];
cin.getline(s,4); &#x2F;&#x2F;只读入3位（会存&#39;\0&#39;）
int n &#x3D; strlen(s);
cout &lt;&lt; s &lt;&lt; &quot; &quot;;
cout &lt;&lt; n &lt;&lt; &quot; &quot;;
cout &lt;&lt; sizeof(s) &lt;&lt; &quot; &quot;;

char* q&#x3D;&quot;abcde&quot;;
q+&#x3D;2;
cout&lt;&lt;q; &#x2F;&#x2F;cde<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><blockquote><p>输入：ABCDE</p><p>输出：ABC 3 5</p></blockquote><p>（8）5 4 6</p><p><img data-src="https://cdn.jsdelivr.net/gh/rainnn-w/Pictures@main/blog/202308281108350.png" alt="image-20230615170300301"></p><h4 id="指针阅读程序"><a class="anchor" href="#指针阅读程序">#</a> 指针阅读程序</h4><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a[] &#x3D; &#123;1,2,3,4,5&#125;;
   int *p; &#x2F;&#x2F;a[0]
   p &#x3D; a+1; &#x2F;&#x2F;a[1]
   cout &lt;&lt; a &lt;&lt; endl; &#x2F;&#x2F;地址
   cout &lt;&lt; &amp;a &lt;&lt; endl; &#x2F;&#x2F;与a相同 地址
   &#x2F;&#x2F;cout &lt;&lt; a++ &lt;&lt; endl; &#x2F;&#x2F;Error
   cout &lt;&lt; &amp;a+1 &lt;&lt; endl; &#x2F;&#x2F;下一位地址
   cout &lt;&lt; *(a+1) &lt;&lt; endl; &#x2F;&#x2F;2
   cout &lt;&lt; *p &lt;&lt; p[1] &lt;&lt; a[1] &lt;&lt; endl;&#x2F;&#x2F;232
   cout &lt;&lt; *p++ &lt;&lt; endl; &#x2F;&#x2F;2 a[2]
   (*p)++; &#x2F;&#x2F; a[2]++ 即a[2]&#x3D;4
   cout &lt;&lt; p &lt;&lt; endl; &#x2F;&#x2F;输出地址
   cout &lt;&lt; *p &lt;&lt; endl; &#x2F;&#x2F;4
   cout &lt;&lt; *(a+2); &#x2F;&#x2F;4 此时a[2]已经等于4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;指针数组
    int a[]&#x3D;&#123;1,3,5,7,9&#125;;
    int *p[]&#x3D;&#123;a,a+1,a+2,a+3,a+4&#125;;
    cout &lt;&lt; a[4] &lt;&lt; endl; &#x2F;&#x2F;9
    cout &lt;&lt; &amp;a[4] &lt;&lt; endl; &#x2F;&#x2F;地址 0x61fe10
    cout &lt;&lt; p[4] &lt;&lt; endl; &#x2F;&#x2F;同上地址 0x61fe10
    cout &lt;&lt; *p[4] &lt;&lt; endl; &#x2F;&#x2F;9
    cout &lt;&lt; &amp;p[4] &lt;&lt; endl; &#x2F;&#x2F;地址 0x61fdf0
    cout &lt;&lt; *(a+4) &lt;&lt; endl;&#x2F;&#x2F;9
    cout &lt;&lt; *(p+4) &lt;&lt; endl; &#x2F;&#x2F;地址 0x61fe10
	cout &lt;&lt; **(p+4) &lt;&lt; endl; &#x2F;&#x2F;9
    cout &lt;&lt; *(p+4)-*(p+0) &lt;&lt; endl; &#x2F;&#x2F;4 运算顺序（
    cout &lt;&lt; (*(p+4)-*(p+0)) &lt;&lt; endl; &#x2F;&#x2F;4
    cout &lt;&lt; *(a+3)%a[4] &lt;&lt; endl; &#x2F;&#x2F;7 （7%9）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;数组指针
    int (*p)[5];
    int a[5]&#x3D;&#123;1,3,5,7,9&#125;;
    cout &lt;&lt; p &lt;&lt; endl; &#x2F;&#x2F;地址0x10
    cout &lt;&lt; a &lt;&lt; endl; &#x2F;&#x2F;地址0x61fe00
    cout &lt;&lt; p[2] &lt;&lt; endl; &#x2F;&#x2F;地址0x38
    cout &lt;&lt; *p &lt;&lt; endl; &#x2F;&#x2F;地址0x10
    cout &lt;&lt; a+2 &lt;&lt; endl; &#x2F;&#x2F;地址0x61fe08
    cout &lt;&lt; *(a+2) &lt;&lt; endl; &#x2F;&#x2F;5
    cout &lt;&lt; p++ &lt;&lt; endl; &#x2F;&#x2F;地址0x10
    cout &lt;&lt; *p++ &lt;&lt; endl; &#x2F;&#x2F;地址0x24
    cout &lt;&lt; *p &lt;&lt; endl; &#x2F;&#x2F;0x38<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h4 id="派生类构造函数"><a class="anchor" href="#派生类构造函数">#</a> 派生类构造函数</h4><p>1. 调用基类构造函数，对基类数据成员初始化；</p><p>2. 调用子对象构造函数，对子对象数据成员初始化；</p><p>3. 再执行派生类构造函数本身，对派生类数据成员初始化。</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
class A&#123;
	public: A(int aa)&#123;cout&lt;&lt; aa;&#125;;
&#125;;
class B:public A&#123;
	int b; A a;&#x2F;&#x2F; 子对象a
  public:
	B(int bb):a(bb-2),A(bb+1),b(bb+2)&#123;
		b &#x3D; bb-4;
		cout &lt;&lt; b &lt;&lt;endl;
	&#125;
&#125;;
int main()&#123; A a(3); B b(4); &#125;
&#x2F;&#x2F;3520<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><ul><li><p>C++ 声明 + 赋值一个对象指针时，调用默认构造函数。如果只是声明，那 么不会调用构造函数，分配空间给 p，但是不可用。</p></li><li><p>默认构造函数（即无参构造函数）不一定存在，但是拷贝构造函数总是会存在。</p></li></ul><h2 id="一-概述"><a class="anchor" href="#一-概述">#</a> 一、概述</h2><h3 id="一程序设计语言"><a class="anchor" href="#一程序设计语言">#</a> （一）程序设计语言</h3><h4 id="1低级语言"><a class="anchor" href="#1低级语言">#</a> 1. 低级语言</h4><ul><li><p>机器语言（采用指令编码和数据的存储地址来表示指令的操作以及操作数）</p><p>可以直接在计算机上执行</p></li><li><p>汇编语言（用符号来表示指令的操作以及操作数）</p><p>必须翻译成机器语言才能执行（翻译工作由程序 assembler 汇编程序 来自动完成）</p></li></ul><h4 id="2高级语言"><a class="anchor" href="#2高级语言">#</a> 2. 高级语言</h4><h3 id="二c程序的构成"><a class="anchor" href="#二c程序的构成">#</a> （二）c++ 程序的构成</h3><p>1. 每个 c++ 程序必须有且仅有一个名字为 main 的全局函数，称为主函数，程序<strong>从全局函数 main 开始执行</strong>，main 函数的返回值类型为 <code>int</code></p><blockquote><p>一般情况下，返回 0 表示程序正常结束，返回负数（如 - 1）表示程序非正常结束</p></blockquote><p>2. 一个 c++ 程序可以存放在一个或多个文件（称为源文件）中，每个源文件包含一些程序实体的定义，其中有且仅有一个源文件中包含全局函数 <code>main</code></p><h3 id="三词法"><a class="anchor" href="#三词法">#</a> （三）词法</h3><p>1. 标识符</p><ul><li><p>标识符命名规则：</p><ul><li>由 ** 大小写中英文字母、数字、下划线、美元符号（$)** 构成</li><li><strong>第一个字符不能是数字</strong></li><li>标识符通常用作程序实体的名字</li><li><strong>大小写字母有区别</strong></li></ul><p>（C++ 语言保留了一些名字供语言本身使用，这些名字不能被用作标识符。）</p></li></ul><p>2. 关键字</p><p>3. 字面常量</p><p>4. 操作符</p><p>5. 标点符号</p><ul><li><p>注释不构成可执行程序的一部分</p><p>不参加编译，也不会出现在目标程序中</p></li><li><p>预处理和函数头后面不需要加 <code>;</code> 表示结束</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p></li><li><p>续行符 <code>\</code> （将一个单词分成多行来写，需在每行最后加续行符）</p></li></ul><h3 id="四cpp程序的运行"><a class="anchor" href="#四cpp程序的运行">#</a> （四）cpp 程序的运行</h3><blockquote><ul><li>编写 C++ 程序一般需经过的几个步骤依次是：编辑、编译、连接、运行</li><li>程序执行的顺序：本程序文件的 main 函数开始，到 main 函数结束</li></ul></blockquote><ul><li>源程序的扩展名： <code>.cpp</code> / <code>.h</code></li><li>目标文件： <code>.obj</code></li><li>可执行文件： <code>.exe</code></li></ul><h3 id="五进制转换"><a class="anchor" href="#五进制转换">#</a> （五）进制转换</h3><ul><li><p>十进制整数 ---- 二进制 / 八进制 / 十六进制：除以 2/8/16 从下往上取余</p></li><li><p>十进制小数 ---- 二进制 / 八进制 / 十六进制：乘以 2/8/16 从上往下取整</p></li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/rainnn-w/Pictures@main/blog/202308281109020.png" alt="image-20230305174903120"></p><ul><li>二进制 / 八进制 / 十六进制 ---- 十进制：</li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/rainnn-w/Pictures@main/blog/202308281109311.png" alt="image-20230305175103292"></p><ul><li>二进制 ---- 八进制 / 十六进制：</li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/rainnn-w/Pictures@main/blog/202308281109178.png" alt="image-20230305175202024"></p><h3 id="六原码-反码-补码"><a class="anchor" href="#六原码-反码-补码">#</a> （六）原码 反码 补码</h3><ul><li>原码：2 进制表示 （通常最高位表示正负 1 负 0 正）</li></ul><blockquote><p>对于 n 个二进制位构成的原码，能表示的整数范围为 -(2<sup>(n-1)-1)~2</sup>(n-1)-1</p></blockquote><ul><li>补码：<ul><li>正整数：原码</li><li>负整数：原码各位取反后加 1</li></ul></li></ul><blockquote><p>对于 n 个二进制位构成的补码，能表示的整数范围为 -2<sup>(n-1)~2</sup>(n-1)-1</p></blockquote><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3JhaW5ubi13L1BpY3R1cmVzQG1haW4vYmxvZy8yMDIzMDgyODExMDkxMTgucG5n">https://cdn.jsdelivr.net/gh/rainnn-w/Pictures@main/blog/202308281109118.png</span>&quot; alt=&quot;image-20230615162922367&quot; style=&quot;zoom:33%;&quot; /&gt;（A）</p><ul><li>加减法<ul><li>加：补码直接相加，舍去最高位</li><li>减：减数取负，与被减数相加，舍去最高位</li></ul></li></ul><h2 id="二-基本数据类型和表达式"><a class="anchor" href="#二-基本数据类型和表达式">#</a> 二、基本数据类型和表达式</h2><p><img data-src="https://cdn.jsdelivr.net/gh/rainnn-w/Pictures@main/blog/202308281109044.jpg" alt="img"></p><h3 id="一基本数据类型"><a class="anchor" href="#一基本数据类型">#</a> （一）基本数据类型</h3><p>![image-20230330112752014](./C++ Notes/image-20230330112752014.png)</p><blockquote><p>可以使用 <code>sizeof(&lt;类型&gt;)</code> 或 <code>sizeof(&lt;变量&gt;)</code> 运算其字节长度</p></blockquote><h4 id="1整数类型"><a class="anchor" href="#1整数类型">#</a> 1. 整数类型</h4><ul><li><p><code>int</code> 2/4 字节 （由计算机字长决定）</p></li><li><p><code>short int</code> <code>short</code> 2 字节</p></li><li><p><code>long int</code> <code>long</code> 4 字节</p></li><li><p>无符号整数类型</p><ul><li><code>unsigned int</code> / <code>unsigned</code></li><li><code>unsigned short int</code> / <code>unsigned short</code></li><li><code>unsigned long int</code> / <code>unsigned long</code></li></ul><blockquote><p>无符号整数类型所占内存大小与相应整数类型相同</p><p>有符号整数类型的数，分配给其内存空间中会占用一个二进制位表示它的符号</p><p>但无符号整数类型其内存空间中没有表示符号的位</p></blockquote></li></ul><h4 id="2实数类型浮点类型默认为double"><a class="anchor" href="#2实数类型浮点类型默认为double">#</a> 2. 实数类型（浮点类型）默认为 <code>double</code></h4><ul><li><code>float</code> 4 个字节</li><li><code>double</code> 8 个字节</li><li><code>long double</code> 8/10 个字节</li></ul><h4 id="3字符类型"><a class="anchor" href="#3字符类型">#</a> 3. 字符类型</h4><ul><li><p><code>char</code> 1 个字节</p></li><li><p><code>wchar_t</code></p></li></ul><blockquote><p>ASCII 字符集：a--97 A--65</p></blockquote><h4 id="4逻辑类型-bool"><a class="anchor" href="#4逻辑类型-bool">#</a> 4. 逻辑类型 <code>bool</code></h4><ul><li>1 真 true</li><li>0 假 false</li></ul><h4 id="5空值类型"><a class="anchor" href="#5空值类型">#</a> 5. 空值类型</h4><ul><li><code>void</code></li><li><code>void*</code> 通用指针类型</li></ul><h3 id="二表现形式"><a class="anchor" href="#二表现形式">#</a> （二）表现形式</h3><h4 id="1常量"><a class="anchor" href="#1常量">#</a> 1. 常量</h4><ul><li><p>字面常量 在程序中直接写出常量值的常量</p><ul><li><p>整数类型常量</p><ul><li>十进制 第一个数字不能是 0（0 除外）</li><li>八进制 由 0 开头</li><li>十六进制 由 0x 或 0X 开头</li></ul></li><li><p>实数类型常量</p><ul><li>小数：可以省略小数点前后的 0 <code>5.</code> <code>.5</code></li><li>科学计数法： <code>4.2E2</code> = 4.2*10^2</li></ul></li><li><p>字符类型常量</p><p><code>'A'</code> <code>\101</code> （八进制） <code>\x41</code> （十六进制）</p><p><code>'\n’</code> （换行符） <code>‘\r’</code> （回车符） <code>‘\t’</code> （横向制表符） <code>‘\b’</code> （退格符） <code>‘\a’</code> （响铃） <code>'\f'</code> （换页，在打印机上，屏幕上没有页）</p></li></ul></li><li><p>字符串常量 为一维字符数组</p></li><li><p>符号常量 有名字的常量</p><p><code>const double PI=3.14;</code></p><p><code>#define PI 3.14</code></p><p><strong>（ <code>#define</code> 定义的标识符在编译前将被替换成所定义的内容）</strong></p></li></ul><h4 id="2变量"><a class="anchor" href="#2变量">#</a> 2. 变量</h4><blockquote><p>变量有一定的<strong>生存周期</strong>和<strong>作用范围</strong></p></blockquote><p><code>int a=5;</code></p><p><code>int a(5);</code></p><ul><li>定义</li><li>赋值：对内存空间初始化</li><li>使用：获取，或者改变内存空间的数值</li></ul><h3 id="三操作符"><a class="anchor" href="#三操作符">#</a> （三）操作符</h3><blockquote><p>又称作：运算符 数据称为：操作数</p><p>操作符的优先级：</p><p><img data-src="https://cdn.jsdelivr.net/gh/rainnn-w/Pictures@main/blog/202308281109105.png" alt="image-20230305202512335"></p></blockquote><h4 id="1算术操作符"><a class="anchor" href="#1算术操作符">#</a> 1. 算术操作符</h4><ul><li>加 <code>+</code> 、减 <code>-</code> 、乘 <code>*</code> 、除 <code>/</code> 、取余 <code>%</code></li><li>取负 取正 <code>-</code> <code>+</code></li><li>自增、自减 <code>++</code> <code>--</code></li></ul><p>例题：可以使 x 的值增大 2： <code>++ ++x</code> <code>(++x)++</code></p><p>❌： <code>x++ ++</code> <code>++x++</code></p><h4 id="2关系与逻辑操作符"><a class="anchor" href="#2关系与逻辑操作符">#</a> 2. 关系与逻辑操作符</h4><h5 id="1关系操作符"><a class="anchor" href="#1关系操作符">#</a> （1）关系操作符</h5><p><code>&gt;</code> <code>&lt;</code> <code>&gt;=</code> <code>&lt;=</code> <code>==</code> <code>!=</code></p><h5 id="2逻辑操作符"><a class="anchor" href="#2逻辑操作符">#</a> （2）逻辑操作符</h5><p><code>&amp;&amp;</code> 逻辑与 <code>||</code> 逻辑或 <code>!</code> 逻辑非</p><p>例：3&amp;&amp;5 的结果为：1</p><p>解析：3：11</p><p>​ 5：101</p><p>​ 11&amp;&amp;101 = 001 = 1</p><blockquote><p>短路求值</p></blockquote><h4 id="3位操作符"><a class="anchor" href="#3位操作符">#</a> 3. 位操作符</h4><h5 id="1逻辑位操作"><a class="anchor" href="#1逻辑位操作">#</a> （1）逻辑位操作</h5><p><code>~</code> 按位取反 二进制取反</p><p><code>&amp;</code> 按位与</p><p>例：若有变量定义 int a = 13, b = 6; 则表达式 a &amp; b 的值为：4</p><p>13=1101<br>6=0110</p><p>1101 &amp; 0110 = 0100 = 4<br>1101 ^ 0110 = 1011 = 11</p><p><code>|</code> 按位或</p><p><code>^</code> 按位异或 相同为 0，不同为 1</p><blockquote><p><code>(x^a)^a=x</code></p></blockquote><h5 id="2移位操作"><a class="anchor" href="#2移位操作">#</a> （2）移位操作</h5><ul><li><p><code>&lt;&lt;</code> 左移</p><p>把第一个操作数按二进制位依次左移由第二个操作数所指定的位数。左移时，高位舍弃，低位补 0。</p></li><li><p><code>&gt;&gt;</code> 右移</p><p>把第一个操作数按二进制位依次右移由第二个操作数所指定的位数。右移时，低位舍弃，高位按下面规则处理：</p><ul><li>对于无符号数或有符号的非负数，高位补 0</li><li>对于有符号数的负数，高位与原来的最高位相同（适合于补码表示的整数）</li></ul></li></ul><blockquote><p>移位操作常常用于实现特殊的乘法和除法运算。</p><p>例如，在某些情况下</p><ul><li>把一个整型数按二进位左移一位相当于把该整型数乘以 2，</li><li>把一个整型数按二进位右移一位相当于把该整型数除以 2，</li></ul></blockquote><h4 id="4赋值运算符"><a class="anchor" href="#4赋值运算符">#</a> 4. 赋值运算符</h4><ul><li>cpp 允许连续使用赋值运算符</li></ul><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a;
int b;
int c;
a&#x3D;b&#x3D;c&#x3D;88;&#x2F;&#x2F;88先被赋值给c，c的值被赋给b，b的值被赋给a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><h4 id="5其他操作符"><a class="anchor" href="#5其他操作符">#</a> 5. 其他操作符</h4><h5 id="1条件操作符"><a class="anchor" href="#1条件操作符">#</a> （1）条件操作符</h5><p><code>d1?d2:d3</code></p><p>如果 d1 的值为 true 或非零，则运算结果为 d2，否则为 d3</p><h5 id="2逗号操作符"><a class="anchor" href="#2逗号操作符">#</a> （2）逗号操作符</h5><p><code>d1,d2,d3,...</code> 将若干个运算连接起来</p><p>从左至右依次进行各个运算，操作结果为最后一个运算的<br>结果。</p><p>例： <code>x=a+b,y=c+d,z=x+y</code> 等价于 <code>z=a+b+c+d</code></p><h5 id="3sizeof操作符"><a class="anchor" href="#3sizeof操作符">#</a> （3）sizeof 操作符</h5><ul><li><code>sizeof(类型名/变量名)</code> 计算各种数据类型的数据所占内存空间大小</li></ul><blockquote><p>CHAR_MAX</p><p>SHRT_MAX</p><p>INT_MAX</p><p>LONG_MAX</p><p>LLONG_MAX long long</p></blockquote><ul><li><code>typedef &lt;已有类型&gt; &lt;别名&gt;</code> 给已有数据类型取别名</li></ul><h4 id="6操作数的类型转换"><a class="anchor" href="#6操作数的类型转换">#</a> 6. 操作数的类型转换</h4><h5 id="1隐式类型转换"><a class="anchor" href="#1隐式类型转换">#</a> （1）隐式类型转换</h5><p><code>char</code> , <code>short</code> , <code>int</code> , <code>unsigned int</code> , <code>long int</code> , <code>unsigned long int</code></p><p>（将 <code>char</code> , <code>signed char</code> , <code>unsigned char</code> , <code>short int</code> , <code>unsigned short int</code> )</p><p><code>float</code> , <code>double</code> , <code>long double</code></p><h5 id="2显式类型转换"><a class="anchor" href="#2显式类型转换">#</a> （2）显式类型转换</h5><p><code>&lt;类型名&gt;(&lt;操作数&gt;)</code></p><p><code>(&lt;类型名&gt;)&lt;操作数&gt;</code></p><h2 id="三-控制语句"><a class="anchor" href="#三-控制语句">#</a> 三、控制语句</h2><h3 id="一选择"><a class="anchor" href="#一选择">#</a> (一）选择</h3><h4 id="1if"><a class="anchor" href="#1if">#</a> 1.if</h4><h4 id="2switch"><a class="anchor" href="#2switch">#</a> 2.switch</h4><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">switch (&lt;整型表达式&gt;)
&#123;
        case&lt;整型常量表达式&gt;:
        	&lt;语句&gt;;
       		break;
        case&lt;整型常量表达式&gt;:
        	&lt;语句&gt;;
        	break;
        case&lt;整型常量表达式&gt;:
        	&lt;语句&gt;;
        	break;
        ...
        default:&lt;语句&gt;;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="二循环"><a class="anchor" href="#二循环">#</a> （二）循环</h3><h4 id="1while"><a class="anchor" href="#1while">#</a> 1.while</h4><h4 id="2do-while"><a class="anchor" href="#2do-while">#</a> 2.do-while</h4><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">do
&#123;&lt;语句&gt;;
 &lt;语句&gt;;
&#125;while(&lt;表达式&gt;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><blockquote><p>注意： <code>while</code> 后的 <code>;</code></p></blockquote><h4 id="3for"><a class="anchor" href="#3for">#</a> 3.for</h4><h3 id="三无条件转移"><a class="anchor" href="#三无条件转移">#</a> （三）无条件转移</h3><h4 id="1goto"><a class="anchor" href="#1goto">#</a> 1.goto</h4><ul><li>不能用 <code>goto</code> 从一个函数外部转入该函数内部，也不能用 <code>goto</code> 从一个函数内部转到该函数外部</li><li>不能掠过带有初始化的变量定义</li></ul><h4 id="2break"><a class="anchor" href="#2break">#</a> 2.break</h4><ul><li>立即跳出循环</li></ul><h4 id="3continue"><a class="anchor" href="#3continue">#</a> 3.continue</h4><ul><li>只能用在循环语句的循环体中</li><li>结束当前循环，进入下一次循环</li></ul><h4 id="4return"><a class="anchor" href="#4return">#</a> 4.return</h4><h2 id="四-函数"><a class="anchor" href="#四-函数">#</a> 四、函数</h2><h3 id="1函数定义"><a class="anchor" href="#1函数定义">#</a> 1. 函数定义</h3><p><code>&lt;返回值类型&gt; &lt;函数名&gt; (&lt;形式参数表&gt;) &lt;函数体&gt;</code></p><p>例： <code>int factorial(int n)&#123; &#125;</code></p><ul><li>return 语句：若返回值类型与 return 的类型不同，会存在隐式类型转换，把 return 的类型转成 &lt;返回值类型&gt;</li><li><strong>函数的定义不可以嵌套</strong></li></ul><h3 id="2函数调用"><a class="anchor" href="#2函数调用">#</a> 2. 函数调用</h3><p><code>&lt;函数名&gt; (&lt;实在参数表&gt;)</code></p><p>例： <code>factorial(5);</code></p><ul><li><p>实参个数和类型与函数形参相同，若类型不同，会隐式转换，把实参类型转换成形参类型。</p></li><li><p>函数调用执行过程</p><ul><li><p>计算实参的值</p></li><li><p>把实参分别传递给被调用函数的相应形参</p><blockquote><p>为形参分配临时内存空间</p></blockquote></li><li><p>执行函数体</p><blockquote><p>为局部变量分配临时内存空间</p><p>当函数的语句部分执行结束后，释放进入函数时所申请的所有临时变量空间，这包括形式参数和局部变量两个部分。</p></blockquote></li><li><p>函数体中执行 <code>return</code> 语句返回函数调用点，调用点获得返回值（如果有返回值）并执行调用后的操作</p></li></ul></li><li><p>函数参数传递</p><ul><li>值传递（默认）</li></ul><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;例题
void swap(int x,int y)&#123;
    int temp;
    temp &#x3D; x;
    x &#x3D; y;
    y &#x3D; temp;
&#125;
int main()&#123;
    int a &#x3D; 2,b &#x3D; 3;
    swap(a,b);
    cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;
    return 0;
&#125;
&#x2F;&#x2F; 2 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><ul><li>地址或引用传递</li></ul></li></ul><h3 id="3函数声明"><a class="anchor" href="#3函数声明">#</a> 3. 函数声明</h3><ul><li>调用的函数都要有定义，若定义在调用点之后或其他文件中，需要在调用前对被调用的函数进行声明。</li></ul><p><code>&lt;返回值类型&gt; &lt;函数名&gt; (&lt;形式参数表&gt;)</code></p><p>或 <code>extren &lt;返回值类型&gt; &lt;函数名&gt; (&lt;形式参数表&gt;)</code></p><ul><li>在函数声明中，形式参数表可以只列出参数类型而不写形参名</li></ul><p>例： <code>int g(int,int);</code></p><ul><li>在函数里面也可以声明</li></ul><h3 id="4局部变量与全局变量"><a class="anchor" href="#4局部变量与全局变量">#</a> 4. 局部变量与全局变量</h3><h4 id="1局部变量"><a class="anchor" href="#1局部变量">#</a> （1）局部变量</h4><ul><li>在复合语句中定义的变量，只能在定义他们的复合语句中使用</li><li>函数的形式参数与可以看成是局部变量</li></ul><h4 id="2全局变量"><a class="anchor" href="#2全局变量">#</a> （2）全局变量</h4><ul><li><p>在函数外部定义的变量</p></li><li><p><strong>若全局变量定义在使用点之后或其他文件里，使用前需对其声明</strong>。</p><p><code>extern &lt;变量类型&gt; &lt;变量名&gt;</code></p></li><li><p>变量定义也属于一种声明：定义性声明</p><ul><li>变量定义要给变量分配空间，变量声明则不用</li><li>变量定义要给变量赋初值（初始化变量），变量声明则不可以。</li><li>变量定义只能有一个，变量声明可以有多个。</li></ul></li><li><p><code>static</code> 全局变量：存储在静态存储区，<strong>在函数外部定义</strong>，<strong>只限在本文件中使用</strong></p><p><code>extern</code> 全局变量：存储在静态存储区，<strong>在其他文件中定义</strong>，<strong>在本文件中可以使用</strong></p><p><code>static</code> 局部变量：存储在静态存储区，在函数内部定义，只限在函数内部使用</p></li></ul><h3 id="5程序的多模块结构"><a class="anchor" href="#5程序的多模块结构">#</a> 5. 程序的多模块结构</h3><ul><li><p>一个程序模块包含两个部分：</p><ul><li>接口 interface （.h 文件 头文件）在本模块中定义的、提供给其他模块使用的一些程序实体的定义（常量、类型等）和声明（函数、全局变量等）</li><li>实现 implementation （.cpp 文件 源文件）模块中程序实体的定义</li></ul></li><li><p>在一个模块 A 中用到另一个模块 B 中定义的全局程序文件，要在 A 的源文件中用一条编译预处理命令（ <code>#include</code> ）把 B 的头文件中的内容包含进来，达到声明的目的。</p></li><li><p>文件包含命令： <code>#include &lt;文件名&gt;</code> 或 <code>#include &quot;文件名&quot;</code></p><blockquote><p>include 命令的含义是：在编译前，用文件名所指定的文件内容替换该命令</p></blockquote><ul><li><p>&lt;文件名&gt; 表示在<strong>系统指定的目录</strong>下寻找指定文件</p></li><li><p>&quot;文件名&quot; 表示先在 #include 命令的<strong>源文件所在的目录</strong>下查找，然后再在<strong>系统指定的目录</strong>下寻找指定文件</p><blockquote><p>如果几个目录中都有 xx.h， <code>#include &quot;xx.h&quot;</code> 最多只会搜索到第一个就停止继续搜索</p></blockquote></li></ul></li></ul><h3 id="6标识符的作用域"><a class="anchor" href="#6标识符的作用域">#</a> 6. 标识符的作用域</h3><h4 id="1局部作用域"><a class="anchor" href="#1局部作用域">#</a> （1）局部作用域</h4><ul><li><p>在函数定义或复合语句中、从标识符的定义点开始到函数定义或复合语句结束之间的程序段。</p></li><li><p>具有局部作用域的标识符：局部常量名、局部变量名 / 对象名、函数的形参名</p></li><li><p>如果在一个标识符的局部作用域中包含内层复合语句，并且在该内层复合语句中定义了一个同名的不同实体，则外层定义的标识符的作用域应该是从其潜在作用域中扣除内层同名标识符的作用域之后所得到的作用域。</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void f()&#123;
    int x;&#x2F;&#x2F;外层x的定义
    ... x ...&#x2F;&#x2F;外层的x
    while ( ... x ...)&#123;&#x2F;&#x2F;外层的x
    	...x...&#x2F;&#x2F;外层的x
        double x;&#x2F;&#x2F;内层的x
        ...x...&#x2F;&#x2F;内层的x
    &#125;
    ...x...&#x2F;&#x2F;外层的x
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li></ul><h4 id="2全局作用域"><a class="anchor" href="#2全局作用域">#</a> （2）全局作用域</h4><p>（具有全局作用域的标识符主要用于标识被程序<strong>各个模块共享</strong>的程序实体）</p><ul><li><p>构成 c++ 程序的所有模块（源文件）</p></li><li><p>具有全局作用域的标识符：全局函数名、全局变量名 / 对象名、全局类名</p></li><li><p>若标识符的定义点在其它源文件中或在本源文件中使用点之后，则在使用前需要声明它们。</p></li><li><p>如果在某个局部作用域中定义了与某个全局标识符同名的标识符，则该全局标识符的作用域应扣掉与之同名的局部标识符的作用域。</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int x;&#x2F;&#x2F;外层x的定义
void f()&#123;    
    ... x ...&#x2F;&#x2F;外层的x
    while ( ... x ...)&#123;&#x2F;&#x2F;外层的x
    	...x...&#x2F;&#x2F;外层的x
        double x;&#x2F;&#x2F;内层的x
        ...x...&#x2F;&#x2F;内层的x
    &#125;
    ...x...&#x2F;&#x2F;外层的x
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>若在局部标识符的作用域中要使用与其同名的全局标识符，需要用全局域选择符（ <code>::</code> ）对全局标识符进行修饰（受限）</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double x;&#x2F;&#x2F;外
void f()&#123;
    ...x...&#x2F;&#x2F;外
    int x;&#x2F;&#x2F;内
    x&#x2F;&#x2F;内
    ::x&#x2F;&#x2F;外
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li></ul><h4 id="3文件作用域"><a class="anchor" href="#3文件作用域">#</a> （3）文件作用域</h4><p>（具有文件作用域的标识符用于标识在<strong>一个模块内部共享</strong>的程序实体）</p><ul><li>在全局标识符的定义中加上 <code>static</code></li><li><code>const</code> 定义的全局常量名</li><li>具有文件作用域的标识符只能在定义他们的源文件（模块）中使用</li></ul><h4 id="4函数作用域"><a class="anchor" href="#4函数作用域">#</a> （4）函数作用域</h4><ul><li>语句标号 一个语句标号只能定义一次</li></ul><h4 id="5函数原型作用域"><a class="anchor" href="#5函数原型作用域">#</a> （5）函数原型作用域</h4><ul><li>用于函数声明的函数原型，其中的形式参数名的作用域从函数原型开始到函数原型结束。</li><li><code>void f(int x, double y);</code> 其中的 x 和 y 的作用域是从 <code>(</code> 开始到 <code>)</code> 结束</li></ul><h4 id="6名空间作用域"><a class="anchor" href="#6名空间作用域">#</a> （6）名空间作用域</h4><ul><li>在一个源文件中要用到两个分别在另外两个源文件中定义的不同全局程序实体（如：全局函数），而这两个全局程序实体的名字相同，C++ 提供了名空间 (namespace）设施来解决上述的名冲突问题。</li><li>在一个名空间中定义的全局标识符，其作用域为该<strong>名空间</strong>。</li><li>当在一个名空间外部需要使用该名空间中定义的全局标识符时，可用该<strong>名空间的名字来修饰或受限</strong>。</li></ul><h3 id="7变量的生存期存储分配"><a class="anchor" href="#7变量的生存期存储分配">#</a> 7. 变量的生存期（存储分配）</h3><ul><li><p>生存期：程序运行时一个变量占有内存空间的时间段</p></li><li><p>静态生存期</p><p><strong>从程序开始执行时就进行内存空间分配，直到程序结束才收回它们的空间</strong>。全局变量具有静态生存期。<strong>静态数据区</strong>，系统将未显式初始化的变量初始化为 0</p></li><li><p>自动生存期</p><p><strong>内存空间在程序执行到定义它们的复合语句 (包括函数体）时才分配，当定义它们的复合语句执行结束时，它们的空间将被收回</strong>。局部变量和函数的参数一般具有自动生存期。<strong>栈区 M</strong></p><ul><li>局部变量默认存储类为 <code>auto</code> 使其具用自动生存期</li><li><code>register</code> 使局部变量具有自动生存期，由编译程序根据 CPU 寄存器的使用情况来决定是否存放在寄存器中</li><li><code>static</code> 使局部变量具有静态生存期 只在函数第一次调用时进行初始化，以后调用中不再进行初始化，它的值为上一次函数调用结束时的值。</li></ul><blockquote><p>在全局标识符的定义中， <code>static</code> 用于把全局标识符的作用域改为文件作用域</p><p>在局部变量的定义中， <code>static</code> 用于指出相应的局部变量具有静态生存期。</p></blockquote></li><li><p>动态生存期</p><p>内存空间在程序中显式地用 <code>new</code> 操作或 <code>malloc</code> 库函数分配、用 <code>delete</code> 操作或 <code>free</code> 库函数收回。动态变量具动态生存期。在 ** 堆区 （大小：G）** 中分配</p></li></ul><h3 id="8宏定义"><a class="anchor" href="#8宏定义">#</a> 8. 宏定义</h3><blockquote><p>一种编译预处理命令</p></blockquote><p><code>#define &lt;宏名&gt; (&lt;参数表&gt;) &lt;文字串&gt;</code></p><p>例： <code>#define max(a,b) ((a)&gt;(b)?(a):(b))</code></p><h3 id="9内联函数"><a class="anchor" href="#9内联函数">#</a> 9. 内联函数</h3><ul><li>在定义函数定义时，在函数返回类型之前加上一个 <code>inline</code></li><li>编译时，直接将被调函数体的代码直接插到调用处</li><li>可以提高程序的运行速度</li><li>有些函数即使加上了 <code>inline</code> 关键词，编译程序也不会把它作为内联函数来对待（是否内联由编译器决定）</li></ul><h3 id="10带默认值的形式参数"><a class="anchor" href="#10带默认值的形式参数">#</a> 10. 带默认值的形式参数</h3><ul><li><p>有默认值的形参应处于形参表的<strong>右部</strong>。例如:</p><p><code>void f(int a, int b=1, int c=O);//OK</code></p><p><code>void f(int a, int b=1, int c); //Error</code></p></li><li><p>对参数默认值的指定只在函数声明处有意义。</p></li><li><p>在不同的源文件中，对同一个函数的声明可以对它的同一个参数指定不同的默认值；在同一个源文件中，对同一个函数的声明只能对它的每一个参数指定一次默认值。</p></li></ul><h3 id="11函数名重载"><a class="anchor" href="#11函数名重载">#</a> 11. 函数名重载</h3><ul><li><p><strong>相同函数名，具有不同的参数列表</strong>（参数的类型或个数不同）</p><blockquote><p>参数类型和个数相同，只有返回值类型不同不能对他们重载函数名</p></blockquote></li><li><p>确定一个<strong>对重载函数的调用对应着哪一个重载函数定义的过程</strong>称为<strong>绑定</strong>（binding，又称定联、联编、捆绑)。</p></li><li><p>按参数类型匹配优先级：</p><ul><li>精确匹配：细微的转换（数组名转化成第一个元素的指针、函数名转换成函数指针等）后相同</li><li>提升匹配</li><li>标准转换匹配<ul><li>任何算术类型可以互相转换</li><li>枚举类型可以转换成任何算术类型</li><li>零可以转换成任何算术类型或指针类型</li><li>任何类型的指针可以转换成 void *</li><li>派生类指针可以转换成基类指针</li><li>每个标准转换都是平等的</li></ul></li><li>自定义转换匹配</li></ul></li></ul><h3 id="12λlambda表达式"><a class="anchor" href="#12λlambda表达式">#</a> 12.λ（lambda）表达式</h3><ul><li><p>匿名函数</p></li><li><p><code>[&lt;环境变量使用说明&gt;] &lt;形式参数&gt; &lt;返回值类型&gt; &lt;函数体&gt;</code></p><p>&lt;环境变量使用说明&gt;：</p><ul><li><p>空：不能使用外层作用域中的自动变量</p></li><li><p>&amp;：按引用方式使用外层作用域中的自动变量（可以改变这些变量的值）</p></li><li><p>=：按值方式使用外层作用域中的自动变量（不可以改变这些变量的值）</p><blockquote><p>可以使用 <code>&amp;</code> <code>=</code> 统一指定外层作用域中的自动变量的使用方式，与可以在变量名前加 <code>$</code> <code>=</code> （默认为 <code>=</code> ）单独指定</p></blockquote></li></ul></li></ul><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#123; int k,m,n;
    ... [](int x) -&gt; int &#123;return x;&#125; &#x2F;&#x2F;不能使用k、m、n
    ...[&amp;](int x) -&gt; int &#123;k++,m++,n++; return k+m+n+x;&#125; &#x2F;&#x2F;k、m、n可以被修改
    ...[&#x3D;](int x) -&gt; int &#123;return k+m+n+x;&#125; &#x2F;&#x2F;k、m、n不可以被修改
    ...[&amp;,n](int x) -&gt; int &#123;k++,m++; return x+k+m+n;&#125; &#x2F;&#x2F;n不能被修改
    ...[&#x3D;,&amp;n](int x) -&gt; int &#123;n++; return x+k+m+n;&#125; &#x2F;&#x2F;只有n能被修改
    ...[&amp;k,m](int x) -&gt; int &#123;k++; return x+k+m;&#125; &#x2F;&#x2F;只能使用k、m，k可以被修改
    ...[&#x3D;] &#123;return k+m+n;&#125; &#x2F;&#x2F;没有参数，返回值类型为int（编译器自动确定）
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="五-构造数据类型"><a class="anchor" href="#五-构造数据类型">#</a> 五、构造数据类型</h2><h3 id="一枚举"><a class="anchor" href="#一枚举">#</a> （一）枚举</h3><blockquote><p>设计者自己来定义值集的数据类型</p></blockquote><h4 id="1枚举类型的定义"><a class="anchor" href="#1枚举类型的定义">#</a> 1. 枚举类型的定义</h4><p><code>enum &lt;枚举类型名&gt; &#123;&lt;枚举值表&gt;&#125;</code></p><p>例： <code>enum Day &#123;SUN,MON,TUE,WED,THU,FRI,SAT&#125;</code></p><p>默认情况下，第一个枚举值为 0，以此加 1，也可以显式地给枚举值指定值。</p><p>例： <code>enum Day &#123;SUN=7,MON=1,TUE,WED,THU,FRI,SAT&#125;</code> TUE=2,WED=3......</p><ul><li>枚举类型变量的定义： <code>&lt;枚举类型名&gt;&lt;变量表&gt;;</code> 或 <code>enum &lt;枚举类型名&gt;&lt;变量表&gt;;</code></li><li>枚举类型和枚举类型变量同时定义： <code>enum Day &#123;SUN,MON,TUE,WED,THU,FRI,SAT&#125;d1,d2,d3;</code></li></ul><h4 id="2枚举类型的运算"><a class="anchor" href="#2枚举类型的运算">#</a> 2. 枚举类型的运算</h4><ul><li><p>赋值：</p><ul><li><p>一个枚举类型的变量只能在相应枚举类型的值集中取值。</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Day day;
day &#x3D; SUN;&#x2F;&#x2F;OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><p><s><code>day = 1;</code></s></p></li><li><p>相同枚举类型之间可以进行赋值操作。</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Day d1,d2;
d2 &#x3D; d1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p></li><li><p>可以把一个枚举值赋值给一个整型变量。</p><p><code>int a = d1;</code></p></li><li><p>但不能把一个整型值赋值给枚举类型的变量.</p><p><s><code>d1 = a;</code></s></p><p><code>d1 = (Day)a;//可以，但不安全</code></p></li></ul></li><li><p>比较：</p><p>系统首先将枚举值转换为对应的整型值，然后进行比较。</p></li><li><p>算术运算：</p><p>运算时，将枚举值转换为对应的整型值。</p></li><li><p>不能对枚举类型的值直接进行输入，但可以进行输出。~~ <code>cin &gt;&gt; d</code> ~~ 例：</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Day d;
cout &lt;&lt; d;&#x2F;&#x2F;输出时，枚举类型的值将转换成int型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p></li></ul><h3 id="二数组"><a class="anchor" href="#二数组">#</a> （二）数组</h3><h4 id="1一维数组"><a class="anchor" href="#1一维数组">#</a> 1. 一维数组</h4><h5 id="1定义"><a class="anchor" href="#1定义">#</a> （1）定义：</h5><ul><li>直接定义变量 <code>int a[10]</code></li><li>定义数组类型，再定义变量 <code>typedef int A[10];</code> <code>A a;</code> （数组类型的元素个数是固定的，在程序执行中不能改变）</li><li>不能通过赋值修改数组长度</li></ul><h5 id="2变量的初始化"><a class="anchor" href="#2变量的初始化">#</a> （2）变量的初始化</h5><ul><li><p><code>int a[10]=&#123;1,2,3,4,5,6,7,8,9,10&#125;;</code></p><p>若初始化表中的值的个数少于数组元素个数，则<strong>不足部分的数组元素初始化为 0</strong></p></li><li><p><code>int c[]=&#123;1,2,3&#125;;</code></p><p>若对每个元素都进行了初始化，可以省略元素个数，元素个数由初始化的个数来定</p></li><li><p>若不使用 <code>=&#123;&#125;</code> 赋初值时（此时一定会定义长度）， <code>static</code> 和全局数组均默认其为 0 或‘0’，其他局部数组赋值随机</p></li></ul><h4 id="2一维字符数组"><a class="anchor" href="#2一维字符数组">#</a> 2. 一维字符数组</h4><ul><li><p>在字符串中最后一个字符的后面存储一个 <code>'\0'</code> ，<strong>作为字符串的结束标记</strong></p></li><li><p>若初始化表中的值的个数少于数组元素个数，则<strong>不足部分的数组元素初始化为 '\0'</strong></p></li><li><p>初始化： <code>char s[10]=&#123;'h','e','l','l','o','\0'&#125;;</code></p><p>（只有这种形式程序中必须显式的加上 <code>'\0'</code> ）</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char* buf1 &#x3D; &quot;abcd12345678&quot;;
char buf2[] &#x3D; &quot;abcd12345678&quot;;
cout &lt;&lt; sizeof(buf1) &lt;&lt; endl; &#x2F;&#x2F;8
cout &lt;&lt; sizeof(buf2) &lt;&lt; endl; &#x2F;&#x2F;13 (包含结束符\0)
cout &lt;&lt; strlen(buf1) &lt;&lt; endl; &#x2F;&#x2F;12
cout &lt;&lt; strlen(buf2) &lt;&lt; endl; &#x2F;&#x2F;12

char a[]&#x3D;&#123;&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;&#125;; &#x2F;&#x2F;长度为5
char a[]&#x3D; &quot;hello&quot;; &#x2F;&#x2F;长度为6

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li></ul><h4 id="3二维数组"><a class="anchor" href="#3二维数组">#</a> 3. 二维数组</h4><h5 id="1定义-2"><a class="anchor" href="#1定义-2">#</a> （1）定义：</h5><ul><li><code>int a[10][5]</code></li><li><code>typedef int A[10][5];</code> <code>A a;</code></li></ul><h5 id="2初始化"><a class="anchor" href="#2初始化">#</a> （2）初始化：</h5><ul><li><p><code>int a[2][3]=&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;;</code> 或 <code>int a[2][3]=&#123;1,2,3,4,5,6&#125;;</code></p><p>初始化的值可以少于数组元素的个数，元素默认初始化为 0</p></li><li><p>数组的行数可以省略，其行数由初始化的个数来决定（<strong>只能省略最高维</strong>）</p><p><code>int a[][3]=&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;&#125;;</code></p></li></ul><blockquote><p>由于不存在数组的长度这个属性，在将数组作为函数参数时，通常同时将长度作为参数传输</p><p>在 main 函数中可以使用 <code>sizeof(a)</code> 获得数组长度</p></blockquote><h3 id="三结构类型"><a class="anchor" href="#三结构类型">#</a> （三）结构类型</h3><h4 id="1定义-3"><a class="anchor" href="#1定义-3">#</a> 1. 定义：</h4><ul><li>结构类型定义 <code>struct &lt;结构类型名&gt; &#123;&lt;成员表&gt;&#125;;</code> 例：</li></ul><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct Student&#123;
    int no;
    char name[20];
    Sex sex;
&#125;;
enum Sex &#123;MALE,FEMALE&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><ul><li><p>变量定义 <code>&lt;结构类型名&gt; &lt;变量名表&gt;</code> 或 <code>struct &lt;结构类型名&gt; &lt;变量名表&gt;</code> 例：</p><p><code>Student a,b,c;</code></p></li><li><p>也可以在定义结构类型的同时定义结构类型的变量，这时结构类型名可以省略，例：</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct&#123;
    int x;
    double y;
&#125;a,b;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p></li></ul><blockquote><p><code>struct</code> 默认访问权限是 public， <code>class</code> 默认访问权限是 private</p></blockquote><h4 id="2初始化-2"><a class="anchor" href="#2初始化-2">#</a> 2. 初始化：</h4><p><strong>定义结构类型时不能对其成员初始化</strong>。因为类型不是程序运行时刻的实体，他们不占有内存空间，初始化没意义。可以在定义变量时初始化，例： <code>Student a=&#123;2,Amy,FEMALE&#125;;</code></p><h4 id="3访问结构的成员"><a class="anchor" href="#3访问结构的成员">#</a> 3. 访问结构的成员</h4><p><code>&lt;结构类型变量&gt;.&lt;成员名&gt;</code></p><ul><li><p>不同结构类型的成员的名字可以相同，它们可以与程序中非结构成员的名字相同；</p></li><li><p>结构类型的名字可以与同一作用域中的其他非结构类型标识符相同；</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct A&#123;
    ...;
&#125;;
int A;
...
struct A a;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>对于上述这种情况，使用结构类型 A 必须要在结构类型名前加上关键字 <code>struct</code></p></li></ul><h4 id="4结构数据的赋值"><a class="anchor" href="#4结构数据的赋值">#</a> 4. 结构数据的赋值</h4><ul><li>对结构类型的数据可以整体赋值，但此操作必须要在相同的结构类型之间进行，不同类型结构之间不能相互赋值。</li></ul><h3 id="四联合类型"><a class="anchor" href="#四联合类型">#</a> （四）联合类型</h3><h4 id="1定义-4"><a class="anchor" href="#1定义-4">#</a> 1. 定义：</h4><ul><li>联合类型定义 例：</li></ul><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">union A&#123; &#x2F;&#x2F;A是一个联合类型
    int i;
    char c;
    double d;
&#125;;
A a; &#x2F;&#x2F;a是一个联合类型的变量

...a.i... &#x2F;&#x2F;可以把a作为int型来用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><blockquote><p>联合类型的所有成员占有同一块内存空间，该内存空间的大小为其最大成员所需要的内存空间的大小。</p></blockquote><ul><li>可以进行整体赋值，可传给函数，可作为函数返回值</li></ul><h3 id="五指针类型"><a class="anchor" href="#五指针类型">#</a> （五）指针类型</h3><h4 id="1指针类型的定义"><a class="anchor" href="#1指针类型的定义">#</a> 1. 指针类型的定义</h4><blockquote><p>指针是内存地址的抽象表示，<strong>一个指针代表了一个内存地址</strong></p><p>获取变量的地址： <code>&amp;&lt;变量名&gt;</code></p><p><strong>每一个地址都属于某一种指针类型</strong></p></blockquote><ul><li><code>&lt;类型&gt; *&lt;指针变量&gt;</code></li></ul><p>例： <code>int *p,*q; //p q均为指针变量</code></p><pre><code> 	`int *p,q; //p为指针变量，q为int型变量`

 	`int* p,q; //p为指针变量，q为int型变量`
</code></pre><ul><li><pre><code class="language-c++">typedef &lt;类型&gt;* &lt;指向数据类型数据的指针类型&gt;;
&lt;指向数据类型数据的指针类型&gt; &lt;指针类型的变量名&gt;;
<pre class="line-numbers language-none"><code class="language-none">
例：&#96;typedef int* Pointer;&#96; &#96;Pointer p,q;&#96;

- &#96;void *p&#96; 表明该指针变量可以指向任意类型的数据

- 符号常量&#96;NULL&#96; 空指针

&gt; 指针变量拥有自己的内存空间，**在该空间中存储的是另一个数据的内存地址**
&gt;
&gt; 例：&#96;int x&#x3D;1; int *p&#x3D;&amp;x;&#96;

#### 2.指针类型的基本操作

##### （1）赋值

&#96;&#96;&#96;c++
int x,*p,*p1;
double y,*q;
......
&#x2F;&#x2F;相同类型指针变量可以互相赋值
p &#x3D; &amp;x;
q &#x3D; &amp;y;
p &#x3D; &amp;y; &#x2F;&#x2F;Error 类型不同不能赋值
p1 &#x3D; p;
p &#x3D; 0; &#x2F;&#x2F;使得p不指向任何变量
p &#x3D; 120; &#x2F;&#x2F;Error 120为int型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</code></pre></li></ul><blockquote><p>任意类型的都可以赋给 <code>void*</code> 类型的指针变量</p></blockquote><h5 id="2间接访问操作"><a class="anchor" href="#2间接访问操作">#</a> （2）间接访问操作</h5><p><code>*&lt;指针变量&gt;</code> 访问指针变量所指向的变量</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int x;
int *p &#x3D; &amp;x;
&#x2F;&#x2F;赋值：
x &#x3D; 1; &#x2F;&#x2F;或 
*p &#x3D; 1; &#x2F;&#x2F;此时x&#x3D;1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><blockquote><p>使用指针变量前，必须先给它赋一个指向合法具体对象的地址值</p><p>Error： <code>int *px; *px = x;</code></p><p>Error： <code>char *s; cin&gt;&gt;s;</code></p></blockquote><h5 id="3指针的运算"><a class="anchor" href="#3指针的运算">#</a> （3）指针的运算</h5><h6 id="1一个指针加上或减去一个整型值"><a class="anchor" href="#1一个指针加上或减去一个整型值">#</a> ①一个指针加上或减去一个整型值</h6><blockquote><p>通常用此访问数组元素</p><p>一个指针可以与一个整型值进行加或减运算，运算结果为与该指针同类型的指针</p></blockquote><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a[10];
int *p &#x3D; &amp;a[0]; &#x2F;&#x2F;p指向数组a的第0个元素
p &#x3D; p + 3; &#x2F;&#x2F;p指向数组a的第3个元素
p++; &#x2F;&#x2F;p指向数组a的第4个元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int *p;
double *q;
p++; &#x2F;&#x2F;p的值加sizeof(int)
q -&#x3D;4; &#x2F;&#x2F;q的值减4*sizeof(double)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><p><img data-src="https://cdn.jsdelivr.net/gh/rainnn-w/Pictures@main/blog/202308281109576.jpg" alt="img"></p><p><code>y = *px++;</code> 相当于 <code>y = *px (px++)</code> （取当前元素，指向下一个）</p><h6 id="2两个同类型的指针相减"><a class="anchor" href="#2两个同类型的指针相减">#</a> ②两个同类型的指针相减</h6><blockquote><p>两个同类型的指针相减，结果为两个指针之间相差元素的个数</p><p>两个指针不能相加</p></blockquote><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a[10];
int *p &#x3D; &amp;a[0];
int *q &#x3D; &amp;a[3];
cout &lt;&lt; q-p &lt;&lt; endl; &#x2F;&#x2F;输出3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><h6 id="3两个同类型的指针比较"><a class="anchor" href="#3两个同类型的指针比较">#</a> ③两个同类型的指针比较</h6><p>即：比较他们所对应的内存地址的大小</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a[10],sum &#x3D; 0,*p &#x3D; &amp;a[0],*q &#x3D; &amp;a[3];
while(p&lt;&#x3D;q)&#123;
    sum +&#x3D; *p;
    p++;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h5 id="4指针的输出"><a class="anchor" href="#4指针的输出">#</a> （4）指针的输出</h5><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int x&#x3D;1;
int *p&#x3D;&amp;x;
cout &lt;&lt; p; &#x2F;&#x2F;输出p的值（x的地址）
cout &lt;&lt; *p; &#x2F;&#x2F;输出p指向的值（x的值）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><ul><li>当输出字符指针 <code>*char</code> 时，输出的不是指针值，而是该指针所指向的字符串（特例）</li></ul><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char str[] &#x3D; &quot;ABCD&quot;;
char *p&#x3D;&amp;str[0];
cout &lt;&lt; p; &#x2F;&#x2F;输出p指向的字符串：ABCD
cout &lt;&lt; *p; &#x2F;&#x2F;输出p指向的字符：A

cout &lt;&lt; (void *)p; &#x2F;&#x2F;输出p的值，即字符串&quot;ABCD&quot;的内存首地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h4 id="3指针作为参数类型"><a class="anchor" href="#3指针作为参数类型">#</a> 3. 指针作为参数类型</h4><h5 id="1提高传参效率"><a class="anchor" href="#1提高传参效率">#</a> （1）提高传参效率</h5><h5 id="2通过参数返回函数的计算结果"><a class="anchor" href="#2通过参数返回函数的计算结果">#</a> （2）通过参数返回函数的计算结果</h5><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void swap(int *px, int *py)&#123;
    int t &#x3D; *px;
    *px &#x3D; *py;
    *py &#x3D; t;
&#125;
int main()&#123;
    int a&#x3D;0.b&#x3D;1;
    swap(&amp;a,&amp;b);
    cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b; &#x2F;&#x2F; 1 0
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h5 id="3指向常量的指针"><a class="anchor" href="#3指向常量的指针">#</a> （3）指向常量的指针</h5><ul><li>指向<strong>常量的指针</strong>（常量指针）</li></ul><p><code>const &lt;类型&gt; *&lt;指针变量&gt;</code></p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int *p; &#x2F;&#x2F;p为指向常量的指针变量
const int x &#x3D; 0; &#x2F;&#x2F; 常量必须初始化
p &#x3D; &amp;x;
*p &#x3D; 1; &#x2F;&#x2F;Error 不能通过常量指针改变它所指向的常量的值
int *q;
q &#x3D; &amp;x; &#x2F;&#x2F;Error 指向变量的指针变量不能指向一个常量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a，b；
 const int *p&#x3D;&amp;a &#x2F;&#x2F;常量指针 可以指向变量（但不能改变其值）
&#x2F;&#x2F;那么分为一下两种操作
*p&#x3D;9; &#x2F;&#x2F;操作错误
p&#x3D;&amp;b; &#x2F;&#x2F;操作成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><ul><li><strong>指针类型的常量</strong>（指针常量）是一个常量，但是是指针修饰的</li></ul><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int x,y;
int *const p &#x3D; &amp;x; &#x2F;&#x2F;定义了一个指针类型的常量p，p指向一个变量
*p &#x3D; 1; &#x2F;&#x2F;*p是一个常量
p &#x3D; *y; &#x2F;&#x2F;Error p是一个常量，其值不能被修改<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a，b；
int * const p&#x3D;&amp;a &#x2F;&#x2F;指针常量
&#x2F;&#x2F;那么分为一下两种操作
*p&#x3D;9;&#x2F;&#x2F;操作成功
p&#x3D;&amp;b;&#x2F;&#x2F;操作错误<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><blockquote><ul><li><code>const &lt;类型&gt; *</code> 常量指针：不可以改变值，可以改变指向</li><li><code>* const</code> 指针常量：不可以改变指向，可以改变值</li></ul></blockquote><ul><li>指向常量的指针常量</li></ul><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int x &#x3D; 0,y &#x3D; 1;
const int * const p &#x3D; &amp;x; &#x2F;&#x2F;p是一个指向常量的指针常量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><p>例：<strong>C</strong>（A B 相同）</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">以下哪个仅表示指针指向不能变
A.const char*
B.char const*
C.char* const
D.const char* const<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h5 id="4作为返回值类型"><a class="anchor" href="#4作为返回值类型">#</a> （4）作为返回值类型</h5><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int *max(const int x[], int num)&#123;
    int max_index&#x3D;O;
	for (int i&#x3D;1; i&lt;num; i++)&#123;
        if(x[i]&gt; x[max_index])&#123;
            max_index &#x3D; i;
        &#125;
    &#125;
	return (int*)&amp;x[max_index];
&#125;

int main()&#123;
    int a[100];
    ...
	cout &lt;&lt; *max(a,100)&lt;&lt; endl;
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><ul><li>不能把局部量的地址作为指针返回给调用者</li></ul><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int *f()&#123;
    int i&#x3D;O;
    return &amp;i;
&#125; &#x2F;&#x2F;f调用完i的变量空间就归还了
int*g()&#123;
    int j&#x3D;1; &#x2F;&#x2F;j与i分配的是同一块空间
    return &amp;j;
&#125;
int main()&#123;
    int x ;
    int *p&#x3D;f();
    int *q&#x3D;g();
    x&#x3D;*p+*q;
	cout &lt;&lt;x &lt;&lt;endl; &#x2F;&#x2F;输出2 (p和q用的同一空间，地址相同，该内存空间最后的值是1)
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h4 id="4指针与动态变量"><a class="anchor" href="#4指针与动态变量">#</a> 4. 指针与动态变量</h4><ul><li>数组元素个数不能是变量，必须在编译时就能确定它的值是多少 <s><code>int n; cin &gt;&gt; n; int a[n];</code></s></li></ul><h5 id="1动态变量的创建"><a class="anchor" href="#1动态变量的创建">#</a> （1）动态变量的创建</h5><blockquote><p>动态变量是指在程序运行中，由程序根据需要所创建的变量。</p></blockquote><h6 id="1new-类型名"><a class="anchor" href="#1new-类型名">#</a> ① <code>new &lt;类型名&gt;</code></h6><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int *p, *p0;
p &#x3D; new int;&#x2F;&#x2F;创建了一个int型动态变量，p指向该变量
*p &#x3D; 1; &#x2F;&#x2F;只能通过改变指针变量来访问该动态的整型变量
p0 &#x3D; new int(10); &#x2F;&#x2F;创建一个int型数，并且用()括号中的数据进行初始化<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><p><code>new</code> 操作类型应保持一致</p><h6 id="2new-类型名"><a class="anchor" href="#2new-类型名">#</a> ② <code>new &lt;类型名&gt; [][]</code></h6><blockquote><p>除第一维的大小外，其他维的大小必须是常量或常量表达式</p></blockquote><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int *p; &#x2F;&#x2F;p为指向一个int型数据的指针
int n;
p &#x3D; new int[n];
&#x2F;&#x2F;用 p[i]访问第i个元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int (*q)[20]; &#x2F;&#x2F;q为一个指向由20个int型元素所构成的一维数组的指针
		      &#x2F;&#x2F;等价于typedef int A[20]; A *q;
int n;
...
q&#x3D; new int[n][20]; &#x2F;&#x2F;创建一个n行、20列的二维动态数组，返回第一行的地址。 等价于: q&#x3D;new A[n];
...q[i][j]... &#x2F;&#x2F;访问q指向的二维数组的第i行第j列的元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><ul><li><p>如何创建一个 m 行、n 列的动态数组？</p><ul><li><p>用一维数组实现: <code>int *p=new int[m*n];</code></p></li><li><p>第 i 行、第 j 列元素: <code>*(p+i*n+j)</code></p></li></ul></li></ul><h6 id="3void-mallocunsigned-int-size"><a class="anchor" href="#3void-mallocunsigned-int-size">#</a> ③ <code>void *malloc(unsigned int size)</code></h6><p><code>#include &lt;cstdlib&gt;</code></p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int *p1,*p2,*r;
typedef int A[20];
A *q;
int m,n;
...
p1 &#x3D; (int *)malloc(sizeof(int)); &#x2F;&#x2F;创建一个int型动态变量
p2 &#x3D; (int *)malloc(sizeof(int)*n); &#x2F;&#x2F;创建一个由n个int型元素构成的一维动态数组变量

q &#x3D; (A *)malloc(sizeof(int)*n*20);&#x2F;&#x2F;创建一个n行20列的二维动态数组变量
r &#x3D; (int *)malloc(sizeof(int)*m*n); &#x2F;&#x2F;创建一个隐含的m行n列的二维动态数组变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><ul><li><code>new</code> <code>malloc</code> 区别：<ul><li><code>new</code> 自动计算所需分配的空间大小，而 <code>malloc</code> 需要显式指出</li><li><code>new</code> 自动返回相应类型的指针，而 <code>malloc</code> 要做显式类型转换</li></ul></li></ul><h5 id="2动态变量的访问"><a class="anchor" href="#2动态变量的访问">#</a> （2）动态变量的访问</h5><p>动态变量没有名字，对动态变量的访问需要通过指向动态变量的指针变量来进行（间接访问）。</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int *p,*q;
p &#x3D;new int;
...*p... &#x2F;&#x2F;访问上面创建的int型动态变量q&#x3D;new int[n];
...*(q+3)... &#x2F;&#x2F;或...q[3]...访问上面创建的动态数组中的第4个元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><h5 id="3动态变量的撤销"><a class="anchor" href="#3动态变量的撤销">#</a> （3）动态变量的撤销</h5><ul><li><p>在 C++ 中，动态变量需要由程序显式地撤消（使之消亡）</p><p>例如:<br><code>delete p;//撤消p指向的int型动态变量</code> 或 <code>free(p);</code></p><p>再例如:<br><code>delete []q;//撤消q指向的动态数组</code> 或 <code>free(q);</code></p></li><li><p>一般来说，用 new 创建的动态变量需要用 delete 来撤销；用 malloc 创建的动态变量则需要用 free 撤销。</p></li></ul><h6 id="1delete-指针变量"><a class="anchor" href="#1delete-指针变量">#</a> ① <code>delete &lt;指针变量&gt;</code></h6><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int *p &#x3D; new int;
delete p;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h6 id="2delete-指针变量"><a class="anchor" href="#2delete-指针变量">#</a> ② <code>delete []&lt;指针变量&gt;</code></h6><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int *p &#x3D; new int[20];
delete []p;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h6 id="3void-freevoid-p"><a class="anchor" href="#3void-freevoid-p">#</a> ③ <code>void free(void *p)</code></h6><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">p1 &#x3D; (int *)malloc(sizeof(int));
q &#x3D; (A *)malloc(sizeof(int)*n*20);
free(p);
free(q);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><ul><li><p>用 delete 和 free<strong> 只能撤消动态变量</strong>！<s> <code>int x,*p; p = &amp;x; delete p;</code></s></p></li><li><p>用 delete 和 free 撤消动态数组时，其中的指针变量必须指向数组的第一个元素</p><p><s><code>int *p = new int[n]; p++; delete []p;</code></s></p></li><li><p>悬浮指针</p><p>用 delete 或 free 撤消动态变量后，C++ 编译程序一般不会把指向它的指针变量的值赋为 0，这时该指针指向一个无效空间。</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int *p;
p &#x3D; new int;
delete p;&#x2F;&#x2F;撤销了p所指向的动态变量
*p&#x3D; 1;&#x2F;&#x2F;逻辑错误，P指向的内存空间已经分配给其他动态变量了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p></li><li><p>内存泄漏</p><p>没有撤消动态变量，而把指向它的指针变量指向了别处或指向它的指针变量的生存期结束了，这时，这个动态变量存在但不可访问（这个动态变量已成为一个 “孤儿”），从而浪费空间。</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int x,*p;
p &#x3D; new int[10];&#x2F;&#x2F;动态数组
p&#x3D;&amp;x; &#x2F;&#x2F;之后，上面的动态数组就访问不到了!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p></li></ul><h4 id="5指针与数组"><a class="anchor" href="#5指针与数组">#</a> 5. 指针与数组</h4><blockquote><p>指针访问数组元素能提高效率</p></blockquote><h5 id="1一维数组的首地址"><a class="anchor" href="#1一维数组的首地址">#</a> （1）一维数组的首地址</h5><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a[10]; &#x2F;&#x2F;等价于: typedef int A[10]; A a;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><h6 id="1通过数组首元素来获得"><a class="anchor" href="#1通过数组首元素来获得">#</a> ①通过数组首元素来获得</h6><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int *p;
p &#x3D; &amp;a[0];
或
p &#x3D; a; &#x2F;&#x2F;把一维数组a隐式类型转换成第一个元素的地址: &amp;a[0]
p++;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><ul><li><p>把一维数组传给一个函数时，编译器也会对数组变量进行类型转换 例： <code>int a[10]; f(a);</code> 相当于 <code>f(&amp;a[0]);</code></p></li><li><p>字符串常量也可隐式转换成他的第一个字符在内存中的首地址。</p></li></ul><h6 id="2通过整个数组获得"><a class="anchor" href="#2通过整个数组获得">#</a> ②通过整个数组获得</h6><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">A *q;&#x2F;&#x2F;或int(*q)[10];
q &#x3D; &amp;a; &#x2F;&#x2F;整个数组的地址，它与&amp;a[0]值相同，但类型不同
q++;&#x2F;&#x2F;加:10×sizeof(int)
&#x2F;&#x2F;q为1x10的二维数组，q[0][i]或(*q)[i]用于按行来访问二维数组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><ul><li><p>当创建一个动态的一维数组时，得到的是第一个元素的地址。例如:</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n;
int *p;
p &#x3D; new int[n];&#x2F;&#x2F;创建一个由n个int型元素构成的一维动态数组，返回第一个元素的地址，其类型为: int *<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p></li></ul><h5 id="2多维数组的首地址"><a class="anchor" href="#2多维数组的首地址">#</a> （2）多维数组的首地址</h5><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int b[5][10];&#x2F;&#x2F;等价于: typedef int A[10]; A b[5];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><ul><li><code>int b[2][3]=&#123;1,2,3,4,5,6&#125;</code></li></ul><h6 id="1通过第一行第一列元素来获得"><a class="anchor" href="#1通过第一行第一列元素来获得">#</a> ①通过第一行第一列元素来获得</h6><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int *p;
p&#x3D; &amp;b[0][0];&#x2F;&#x2F;或p&#x3D; b[0];(自动转换成&amp;b[0][0])第一行第一列元素的地址
p++;&#x2F;&#x2F;加:sizeof(int)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><ul><li>访问元素 <code>p[i]</code> <code>*(p+i)</code></li></ul><h6 id="2通过第一行的一维数组来获得"><a class="anchor" href="#2通过第一行的一维数组来获得">#</a> ②通过第一行的一维数组来获得</h6><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">A *q; &#x2F;&#x2F;或int (*q)[10];
q&#x3D;&amp;b[0];&#x2F;&#x2F;或q&#x3D;b; (自动转换成&amp;b[0]) 第一行的地址
q++; &#x2F;&#x2F;加:10×sizeof(int) q指向下一行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><ul><li>访问元素 <code>q[i][j]</code> <code>*(*(q+i)+j)</code></li></ul><p><code>q++</code> （此时指向第 1 行) <code>**q</code> 4（第 1 行第 0 个元素） <code>*(*q+1)</code> 5（第 1 行第 1 个元素） <code>(*q)[1]</code> 5</p><h6 id="3通过整个数组来获得"><a class="anchor" href="#3通过整个数组来获得">#</a> ③通过整个数组来获得</h6><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">B *r; &#x2F;&#x2F;或int (*r)[5][10];
r &#x3D;&amp;b;&#x2F;&#x2F;整个二维数组的地址
r++; &#x2F;&#x2F;加:5×10×sizeof(int)
&#x2F;&#x2F;在三维数组中使用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><ul><li><p>访问元素 <code>r[0][i][j]</code> <code>*(r)[i][j]</code></p></li><li><p>例题：</p></li></ul><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">设int a[3][4]&#x3D;&#123;&#123;1,3,5,7&#125;,&#123;2,4,6,8&#125;&#125;;则*(*a+1)的值为  3 （第0行第1个元素）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><ul><li><p>对于一个动态的 n 维数组，实际上是按一维动态数组来创建的，返回的首地址类型是去掉第一维后的数组指针类型。例如，下面创建一个动态的二维数组：</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef int A[10];&#x2F;&#x2F;A表示一个由10个int型元素所构成的一维数组类型
int m;
A *q;&#x2F;&#x2F;或: int(*q)[10];
q&#x3D; new int[m][10];&#x2F;&#x2F;创建一个由m行10列的二维数组，返回第一行的地址（类型为:A*)。
或
q&#x3D;new A[m];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li></ul><h5 id="3函数main的参数"><a class="anchor" href="#3函数main的参数">#</a> （3）函数 main 的参数</h5><ul><li><p>可以给函数 main 定义参数，其定义格式为: <code>int main(int argc, char *argv[]);</code><br><code>argc</code> 表示传给函数 main 的参数的个数，<br><code>argv</code> 表示各个参数，它是一个一维数组，其每个元素为一个指向字符串的指针。</p></li><li><p>以 <code>“copy file1 file2”</code> 执行程序 copy 时，copy 的函数 main 将得到参数:<br>argc:3<br>argv[0]: &quot;copy&quot;</p><p>argv[1]: &quot;file1&quot;</p><p>argv[2]: &quot;file2&quot;</p></li></ul><h4 id="6函数指针"><a class="anchor" href="#6函数指针">#</a> 6. 函数指针</h4><ul><li><p>C++ 中可以定义一个指针变量，使其指向一个函数。</p></li><li><p>函数指针定义格式： <code>&lt;返回类型&gt; (*&lt;指针类型&gt;)(&lt;形式参数表&gt;)</code></p></li></ul><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double (*fp)(int);&#x2F;&#x2F;fp是一个指向函数的指针变量
或者
typedef double (*FP)(int);
FP fp;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><ul><li><p>对于一个函数，可以用取地址操作符 <code>&amp;</code> 来获得它的内存地址，或直接用函数名来表示。</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double f(int x)&#123; ...&#125;
fp&#x3D; &amp;f;&#x2F;&#x2F;或者，fp &#x3D;f;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p></li><li><p>通过函数指针调用函数可采用下面的形式</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">(*fp)(10); &#x2F;&#x2F;或者，fp(10);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p></li></ul><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;函数指针，可以指向有相同参数列表和返回值的不同名函数
int max(int x,int y)&#123;
    return x&gt;y?x:y;
&#125;
int min(int x,int y)&#123;
    return x&gt;y?y:x;
&#125;

void main(void)&#123;
    int (*p)(int,int);
    p &#x3D; max;
    cout &lt;&lt; p(3,5) &lt;&lt; endl;
    p &#x3D; min;
    cout &lt;&lt; p(3,5) &lt;&lt; endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p><img data-src="https://cdn.jsdelivr.net/gh/rainnn-w/Pictures@main/blog/202308281109515.png" alt="image-20230508153735544"></p><p>A：指向整型量的指针</p><p>B：指向字符型的指针</p><p>C：由指向字符的指针构成的数组，即指针数组</p><p>D：指向字符数组的指针，即数组指针</p><p>F：返回值为指向整型量的指针的函数，即指针函数</p><p>G：指向返回值为整型量的函数的指针，即函数指针</p><h4 id="7多级指针"><a class="anchor" href="#7多级指针">#</a> 7. 多级指针</h4><p>（可能不考 待补充）</p><h4 id="六引用类型变量的别名"><a class="anchor" href="#六引用类型变量的别名">#</a> （六）引用类型（变量的别名）</h4><h4 id="1定义-5"><a class="anchor" href="#1定义-5">#</a> 1. 定义</h4><ul><li><p>定义格式： <code>&lt;类型&gt; &amp;&lt;引用变量&gt;=&lt;变量&gt;</code></p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int x&#x3D;O;
int &amp;y&#x3D;x;&#x2F;&#x2F;y为引用类型的变量，可以看成是x的别名
cout &lt;&lt;x&lt;&lt;&#39;,&#39;&lt;&lt;y &lt;&lt; endl;&#x2F;&#x2F;结果为:0,0
y &#x3D; 1;
cout &lt;&lt;x &lt;&lt;&#39;,&#39;&lt;&lt;y &lt;&lt;endl;&#x2F;&#x2F;结果为:1,1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li><li><p>引用类型用于给一个变量取一个别名。</p></li><li><p>在语法上，<br>对引用类型变量的访问与非引用类型相同。</p></li><li><p>在语义上，<br>对引用类型变量的访问实际访问的是另一个变量（被引用的变量）。<br>效果与通过指针间接访问另一个变量相同。</p></li><li><p>对引用类型需要注意下面几点:</p><ul><li>定义引用类型变量时，应在变量名加上符号 “&amp;”，以区别于普通变量。</li><li><strong>定义引用变量时必须要有初始化</strong>，并且引用变量和被引用变量应具有相同的类型。</li><li>引用类型的变量定义之后，它不能再引用其它变量。</li></ul></li></ul><blockquote><p>引用本质：指针常量</p><p>指针指向不可变，指针指向的值可变</p></blockquote><h4 id="2引用类型作为函数的参数类型"><a class="anchor" href="#2引用类型作为函数的参数类型">#</a> 2. 引用类型作为函数的参数类型</h4><ul><li><p>通过形参改变实参的值</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
void swap(int &amp;x, int &amp;y)&#123;&#x2F;&#x2F;交换两个int型变量的值
    int t;
	t &#x3D; x;
    x &#x3D; y;
    y &#x3D; t;
&#125;
int main()&#123;
    int a&#x3D;0,b&#x3D;1;
    cout &lt;&lt;a&lt;&lt;&#39;,&#39;&lt;&lt;b&lt;&lt; endl; &#x2F;&#x2F;结果为:0,1
    swap(a,b);
	cout &lt;&lt;a&lt;&lt;&#39;,&#39;&lt;&lt;b&lt;&lt;endl; &#x2F;&#x2F;结果为:1,0
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li><li><p>指针的引用</p></li></ul><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
void swap(int *&amp;x, int *&amp;y)&#123;&#x2F;&#x2F;交换两个int型指针变量的值
    int *t;
	t &#x3D; x;
    x &#x3D; y;
    y &#x3D; t;
&#125;
int main()&#123;
    int a&#x3D;0,b&#x3D;1;
    int *p&#x3D;&amp;a,*q&#x3D;&amp;b;
    cout &lt;&lt;*p&lt;&lt;&#39;,&#39;&lt;&lt;*q&lt;&lt; endl; &#x2F;&#x2F;p指向a，q指向b 结果为:0,1
    swap(p,q);
	cout &lt;&lt;*p&lt;&lt;&#39;,&#39;&lt;&lt;*q&lt;&lt;endl; &#x2F;&#x2F;p指向b，q指向a 结果为:1,0
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><ul><li>引用做函数返回值类型</li></ul><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;返回数组中最大元素的引用（注意:不能返回局部变量的引用)
int &amp;max(int x[], int num)&#123;
    int i, j;
	j &#x3D; 0;
	for (i&#x3D;1;i&lt;num;i++)&#123;
        if(x[i]&gt;x[j])&#123;
            j &#x3D; i;
            return x[j];
        &#125;
    &#125;
&#125;
&#x2F;&#x2F;引用具有左值,可以通过返回的引用修改值
int a[10];
cout&lt;&lt;max(a,10)&lt;&lt;endl;
max(a,10)+&#x3D;1; &#x2F;&#x2F;把数组最大元素的值+1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><ul><li><p>通过把形参定义成对常量的引用，可以防止在函数中通过引用类型的形参改变实参的值。</p></li><li><p>引用类型与指针类型的区别</p><ul><li><p>引用类型和指针类型都可以实现通过一个变量访问另一个变量，但在语法上，</p><ul><li><p>引用是采用直接访问形式</p></li><li><p>指针则需要采用间接访问形式</p></li></ul></li><li><p>在作为函数参数类型时，</p><ul><li><p>引用类型参数的实参是一个变量的名字</p></li><li><p>指针类型参数的实参是一个变量的地址</p></li></ul></li><li><p>在定义时初始化以后，</p><ul><li>引用类型变量不能再引用其它变量</li><li>指针类型变量可以指向其它的变量</li></ul></li><li><p>引用类型一般作为指针类型来实现（有时又把引用类型称作隐蔽的指针，hidden pointer)</p></li><li><p>能够用引用实现的指针功能，尽量用引用！</p></li></ul></li></ul><h2 id="六-对象与类"><a class="anchor" href="#六-对象与类">#</a> 六、对象与类</h2><h3 id="一面向对象程序设计"><a class="anchor" href="#一面向对象程序设计">#</a> （一）面向对象程序设计</h3><h4 id="1基础"><a class="anchor" href="#1基础">#</a> 1. 基础</h4><h5 id="1数据抽象"><a class="anchor" href="#1数据抽象">#</a> （1）数据抽象</h5><ul><li>数据的使用者只需要知道对数据所能实施的操作以及这些操作之间的关系，而不必知道数据的具体表示。</li></ul><h5 id="2数据封装"><a class="anchor" href="#2数据封装">#</a> （2）数据封装</h5><ul><li><p>指把数据及其操作作为一个整体来进行描述。</p></li><li><p>数据的具体表示对使用者是不可见的，对数据的访问只能通过封装体所提供的对外接口 (操作）来完成。</p></li></ul><h5 id="3栈"><a class="anchor" href="#3栈">#</a> （3）栈</h5><ul><li><p>栈是一种由若干个具有线性次序关系的元素所构成的复合数据。对栈只能实施两种操作:</p><ul><li><p>进栈（push）: 往栈中增加一个元素</p></li><li><p>退栈（pop）: 从栈中删除一个元素</p><p>上述两个操作必须在栈的同一端（称为栈顶，top）进行。后进先出<br>(Last In First Out，简称 LIFO) 是栈的一个重要性质</p></li></ul></li></ul><h4 id="2对象和类"><a class="anchor" href="#2对象和类">#</a> 2. 对象和类</h4><ul><li>对象是由数据及能对其实施的操作所构成的封装体，它属于值的范畴。</li><li>类描述了对象的特征（包含哪些数据和操作），它属于类型的范畴 (对象的类型)。<ul><li>数据：数据成员、成员变量、实例变量、对象的局部变量等</li><li>操作：成员函数、方法、消息处理过程等</li></ul></li></ul><h4 id="3继承inheritance"><a class="anchor" href="#3继承inheritance">#</a> 3. 继承 (Inheritance)</h4><ul><li>在定义一个新类（派生类、子类）时，可以利用已有类（基类、父类）的一些特征描述。</li><li>单继承与多继承</li><li>作用：分类、代码复用等</li></ul><h4 id="4多态与绑定"><a class="anchor" href="#4多态与绑定">#</a> 4. 多态与绑定</h4><blockquote><p>多态性 (Polymorphism) 动态绑定 (Dynamic Binding)・</p></blockquote><h5 id="1多态"><a class="anchor" href="#1多态">#</a> （1）多态</h5><ul><li>某一论域中的一个元素存在多种解释。通常体现为:<ul><li>一名多用:<ul><li>函数名重载</li><li>操作符重载</li></ul></li><li>类属性:<ul><li>类属函数：一个函数能对多种类型的数据进行操作。</li><li>类属类型：一个类型可以描述多种类型的数据。</li></ul></li></ul></li><li>面向对象程序特有的多态（动态多态）:<ul><li>对象类型的多态：子类对象既属于子类，也属于父类</li><li>对象标识的多态：父类的引用或指针可以引用或指向子类对象</li><li>消息的多态：一个消息集有多种解释（父类与子类有不同解释）</li></ul></li></ul><h5 id="2绑定"><a class="anchor" href="#2绑定">#</a> （2）绑定</h5><ul><li>确定对多态元素的某个使用是多态元素的那一种形式。<ul><li>静态绑定（Static Binding，也称前期绑定，EarlyBinding）: 在编译时刻确定。</li><li>动态绑定（Dynamic Binding，也称后期绑定或延迟绑定 Late Binding）: 在运行时刻确定。</li></ul></li><li>多态带来的好处:<ul><li>易于实现程序高层 (上层）代码的复用。</li><li>使得程序扩充变得容易（只要增加底层的具体实现）。</li><li>增强语言的可扩充性（操作符重载等）。</li></ul></li></ul><h3 id="二类"><a class="anchor" href="#二类">#</a> （二）类</h3><blockquote><p>对象构成了面向对象程序的基本计算单位，而对象的特征则由相应的类来描述。类也可看成是对象的集合。</p></blockquote><h4 id="1数据成员"><a class="anchor" href="#1数据成员">#</a> 1. 数据成员</h4><ul><li><p>数据成员指类的对象所包含的数据，它们可以是常量和变量。数据成员的说明格式与非成员数据的声明格式相同</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Datell&#123;&#x2F;&#x2F;类定义
	private:&#x2F;&#x2F;访问控制说明
      int year,month,day;&#x2F;&#x2F;数据成员说明
&#125;;
例如:class A&#123;
    int x&#x3D;0;&#x2F;&#x2F;Error
	const double y&#x3D;0.0;&#x2F;&#x2F;Error
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li><li><p><strong>说明数据成员时不允许进行初始化</strong>。</p></li></ul><h4 id="2成员函数"><a class="anchor" href="#2成员函数">#</a> 2. 成员函数</h4><ul><li><p>成员函数描述了对类定义中的数据成员所能实施的操作。</p></li><li><p>成员函数的实现也可以放在类定义外</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123;
    void f();&#x2F;&#x2F;声明
&#125;;
void A::f() &#123;...&#125; &#x2F;&#x2F;定义，非内联函数，需要用类名受限，区别于全局函数。
或
inline void A:f() &#123;...&#125; &#x2F;&#x2F;显式说明该成员函数也是一个内联函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li><li><p>类成员函数名是可以重载的（析构函数除外），遵循一般函数名的重载规则</p></li><li><p>成员函数可以对其形参设置默认值</p></li></ul><h4 id="3成员的访问控制"><a class="anchor" href="#3成员的访问控制">#</a> 3. 成员的访问控制</h4><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A
&#123; public:&#x2F;&#x2F;访问不受限制。
	int x;
	void f();
  private: &#x2F;&#x2F;只能在本类和友元的代码中访问。
    int y;
	void g();
  protected: &#x2F;&#x2F;只能在本类、派生类和友元的代码中访问。
    int z;
	void h();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><ul><li>在 C++ 的类定义中，<strong>默认访问控制是 private</strong>（结构和联合成员的默认访问控制为 public)<br>可以有多个 public、private 和 protected 访问控制说明</li></ul><h3 id="三对象"><a class="anchor" href="#三对象">#</a> （三）对象</h3><h4 id="1对象的创建"><a class="anchor" href="#1对象的创建">#</a> 1. 对象的创建</h4><h5 id="1直接方式"><a class="anchor" href="#1直接方式">#</a> （1）直接方式</h5><p><code>Date today,yesterday</code></p><ul><li>全局对象：在函数外定义的对象</li><li>局部对象：在函数内定义的对象</li></ul><h5 id="2间接方式动态对象"><a class="anchor" href="#2间接方式动态对象">#</a> （2）间接方式（动态对象）</h5><ul><li><p>在程序运行时刻，通过 <code>new</code> 操作来创建对象，用 <code>delete</code> 操作来撤消 (使之消亡）。</p><blockquote><p><code>new</code> 创建对象自动调用构造函数<br><code>delete</code> 释放对象自动调用析构函数</p><p>而 <code>malloc</code> 与 <code>free</code> 则否</p></blockquote></li><li><p>通过指针来标识和访问。</p></li><li><p>单个动态对象的创建与撤消</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">A *p;
p &#x3D;new A;&#x2F;&#x2F;创建一个A类的动态对象
...*p...&#x2F;&#x2F;通过p访问动态对象
delete p;&#x2F;&#x2F;撤消p所指向的动态对象。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p></li><li><p>动态对象数组的创建与撤消</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">A *q;
q&#x3D; new A[100]; &#x2F;&#x2F;创建一个动态对象数组。
...q[i]...&#x2F;&#x2F;或者，*(q+i)，通过q访问动态对象数组
delete []q; &#x2F;&#x2F;撤消q所指向的动态对象数组。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p></li></ul><h4 id="2对象的操作"><a class="anchor" href="#2对象的操作">#</a> 2. 对象的操作</h4><ul><li>非动态对象 <code>&lt;对象&gt;.&lt;类成员&gt;</code></li><li>动态对象 <code>&lt;对象指针&gt;-&gt;&lt;类成员&gt;</code> 或 <code>(*&lt;对象指针&gt;).&lt;类成员&gt;</code></li></ul><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123;
     int x;
    public:
     void f();
&#125;;
int main()&#123;
    A a;&#x2F;&#x2F;创建A类的一个局部对象a。
	a.f();&#x2F;&#x2F;调用A类的成员函数f对对象a进行操作。
	A *p&#x3D;new A;&#x2F;&#x2F;创建A类的一个动态对象，p指向之。
	p-&gt;f();&#x2F;&#x2F;调用A类的成员函数f对p所指向的对象进行操作。
    delete p;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><ul><li><p>在类的外部，通过对象来访问类的成员时要受到类成员访问控制的限制</p></li><li><p>可以对同类对象进行赋值</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Date yesterday,today,some_day;
some_day &#x3D; yesterday;&#x2F;&#x2F;把对象yesterday的数据成员分别赋值给对象some_day的相应数据成员。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p></li><li><p>取对象地址</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Date *p_date;
p_date &#x3D; &amp;today;&#x2F;&#x2F;把对象today的地址赋值给对象指针p_date。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p></li><li><p>把对象作为实参传给函数以及作为函数的返回值等操作。</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Date f(Date d)&#123;
    Date x;
	return x;
	some_day2 &#x3D; f(yesterday);&#x2F;&#x2F;调用函数f，把对象yesterday作为实参。返回值对象赋给对象some_day2。
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li></ul><h4 id="3this指针"><a class="anchor" href="#3this指针">#</a> 3. <code>this</code> 指针</h4><ul><li><p>类定义中说明的数据成员（静态数据成员除外）对该类的每个对象都有一个拷贝。</p></li><li><p>实际上，每一个成员函数都有一个隐藏的形参 <code>this</code> ，其类型为： <code>&lt;类名&gt;*const this;</code></p></li><li><p>成员函数所属对象的指针，明确地表示了成员函数当前操作数据所属对象</p></li><li><p>在成员函数中对类成员的访问是通过 this 来进行的。</p></li><li><p>一般情况下，类的成员函数中不必显式使用 this 指针来访问对象的成员（编译程序会自动加上）。</p></li><li><p>如果成员函数中要把 this 所指向的对象作为整体来操作（如：取对象的地址），则需要显式地使用 this 指针。</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void func(A *p);
class A&#123;
    int x;
    public:
      void f()&#123;func(this);&#125; &#x2F;&#x2F;！！！
      void g(int i)&#123;x &#x3D; i; f();&#125;
&#125;;
...
A a,b;
a.f(); &#x2F;&#x2F;要求在f中调用func(&amp;a)
b.f(); &#x2F;&#x2F;要求在f中调用func(&amp;b)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li></ul><h3 id="四对象的初始化和消亡前处理"><a class="anchor" href="#四对象的初始化和消亡前处理">#</a> （四）对象的初始化和消亡前处理</h3><h4 id="1构造函数constructors"><a class="anchor" href="#1构造函数constructors">#</a> 1. 构造函数 (Constructors)</h4><h5 id="1定义-6"><a class="anchor" href="#1定义-6">#</a> （1）定义</h5><ul><li><p>构造函数是类的特殊成员函数，它的<strong>名字与类名相同</strong>、<strong>无返回值类型</strong>。创建对象时，构造函数会自动被调用。</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123;
      int x,y;
	public:
      A()&#123;x &#x3D;0; y &#x3D; 0;&#125;&#x2F;&#x2F;构造函数
    ...
&#125;;
A a; &#x2F;&#x2F;创建对象a:为a分配内存空间，然后调用a的构造函数A()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li><li><p>构造函数可以重载，其中，不带参数的（或所有参数都有默认值的）构造函数被称为<strong>默认构造函数</strong>。(可以不用实参进行调用的构造函数)</p></li><li><p>构造函数一般为 <code>public</code> 可以设置为 <code>private</code></p></li></ul><h5 id="2调用"><a class="anchor" href="#2调用">#</a> （2）调用</h5><ul><li>对象创建后不能再调用构造函数，构造函数的调用是对象创建过程的一部分。</li></ul><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123;
    ...
    public:
      A();
      A(int i);
      A(char *p);
&#125;;
...
A a1; &#x2F;&#x2F;调用默认构造函数  也可写成: A a1&#x3D;A(); 但不能写成: A a1();
A a2(1); &#x2F;&#x2F;调用A(int i)  也可写成:A a2&#x3D;A(1); (显示)或 A a2&#x3D;1;(隐式)
A a3(&quot;abcd&quot;); &#x2F;&#x2F;调A(char *)  也可写成:A a3&#x3D;A(&quot;abcd&quot;); 或A a3&#x3D;&quot;abcd&quot;;
A a[4];&#x2F;&#x2F;调用对象a[0]、a[1]、a[2]、a[3]的默认构造函数。
A b[5]&#x3D;&#123;A(),A(1),A(&quot;abcd&quot;),2,&quot;xyz&quot;&#125;; &#x2F;&#x2F;调用b[0]的A()、b[1]的A(int)、b[2]的A(char *)、b[3]的A(int)和b[4]的A(char *)
A *p1&#x3D;new A;&#x2F;&#x2F;调用默认构造函数。
A *p2&#x3D;new A(2);&#x2F;&#x2F;调用A(int i)。
A *p3&#x3D;new A(&quot;xyz&quot;);&#x2F;&#x2F;调用A(char *)。
A *p4&#x3D;new A[20];&#x2F;&#x2F;创建动态对象数组时只能调用各对象的默认构造函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h5 id="3成员初始化表"><a class="anchor" href="#3成员初始化表">#</a> （3）成员初始化表</h5><ul><li><p>对于常量数据成员和引用数据成员（某些静态成员除外），不能在说明它们时初始化，也不能采用赋值操作对它们初始化（说明数据成员时不允许初始化）</p></li><li><p>对于常量数据成员和引用数据成员，可以在定义构造函数时，在函数头和函数体之间加入一个成员初始化表来对它们进行初始化。例如：</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123;
    int x;
	const int y;
    int &amp;z;
    public:
	  A():x(0),z(x),y(1) &#x2F;&#x2F;成员初始化表(按照 x(0) y(1) z(x)顺序初始化)
      &#123;&#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li><li><p>成员初始化表中成员初始化的书写次序并不决定它们的初始化次序，数据成员的初始化次序由它们在<strong>类定义中的说明次序</strong>来决定。</p></li><li><p>先初始化再执行构造函数体</p></li></ul><blockquote><p>例题：假定 MyClass 为一个类，执行 <code>MyClass a[3],*p[2];</code> 语句时会自动调用该类构造函数 (3) 次</p></blockquote><h4 id="2析构函数destructors"><a class="anchor" href="#2析构函数destructors">#</a> 2. 析构函数 (Destructors)</h4><p><code>~&lt;类名&gt;</code> 没有返回类型、不带参数、不能被重载</p><ul><li>一个对象消亡时，系统在收回它的内存空间之前，将会自动调用析构函数。</li><li>可以在析构函数中完成对象被删除前的一些清理工作（如归还对象额外申请的资源等)。</li><li>析构函数的调用顺序与构造函数的调用顺序完全相反</li></ul><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class String&#123;
    int len;
    char *str;
  public:
    String(char* s)&#123; 
        len &#x3D; strlen(s);
        str &#x3D; new char[len+1];&#x2F;&#x2F;申请资源
        strcpy(str， s); &#x2F;&#x2F;复制字符串
    &#125;
    ~String()&#123;
        delete[] str;&#x2F;&#x2F;归还资源
        str&#x3D;NULL;&#x2F;&#x2F;一般情况下不需要这条语句，有时需要
    &#125;
&#125;
	void f()&#123;
        String s1(&quot;abcd&quot;);&#x2F;&#x2F;调用s1的构造函数
    ......
    &#125;&#x2F;&#x2F;调用s1的析构函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p><img data-src="https://cdn.jsdelivr.net/gh/rainnn-w/Pictures@main/blog/202308281110275.png" alt="image-20230515134011070"></p><p>注意：系统为对象 s1 分配的内存空间只包含 len 和 str（指针）本身所需的空间，str 所指向的空间不由系统分配，而是由对象作为资源自己处理！</p><ul><li>析构函数可以显式调用</li><li>把 string 类的对象 s 变成空字符串的对象，显式调 <code>s1.~String();</code> （只归还对象的资源，对象并未消亡！）</li><li>注意：一般不需要自定义析构函数<ul><li>需要时系统隐式提供，如：需要调用成员对象类和基类的析构函数</li><li>归还资源时需自定义</li></ul></li></ul><h4 id="总结对比"><a class="anchor" href="#总结对比">#</a> 总结对比</h4><h5 id="构造函数的特殊性质"><a class="anchor" href="#构造函数的特殊性质">#</a> 构造函数的特殊性质</h5><ul><li>构造函数的名字必须与类名相同</li><li>构造函数不指定返回类型，它隐含有返回值，由系统内部使用</li><li>构造函数可以有一个或多个参数，因此<strong>构造函数可以重载</strong></li><li>在创建对象时，系统会自动调用构造函数</li></ul><h5 id="析构函数的特殊性质"><a class="anchor" href="#析构函数的特殊性质">#</a> 析构函数的特殊性质</h5><ul><li><p>析构函数名是在类名前加 <code>~</code> 符号</p></li><li><p>析构函数不指定返回类型，它不能有返回值</p></li><li><p>析构函数<strong>没有参数</strong>，因此析构函数不能重载，<strong>一个类中只能定义一个析构函数</strong></p></li><li><p>在撤销对象时，系统会自动调用析构函数</p></li><li><p>析构与构造顺序相反</p></li><li><p>如果一个类没有定义构造和析构函数，则编译器将生成默认构造函数（不必为其提供参数的构造函数）和默认析构函数</p></li></ul><blockquote><p>例题 1</p></blockquote><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;date.h
class Date&#123;
    int year, month, day;
  public:
	Date(int y, int m, int d); &#x2F;&#x2F;构造函数1
    Date(int y&#x3D;2000): year(y)&#123; &#x2F;&#x2F;构造函数2
		month &#x3D; 4;
		day&#x3D;8;
		cout&lt;&lt;&quot;Constructor of Date with 1 parameter.&quot;&lt;&lt;endl;
    &#125;
	~Date()&#123;
            cout&lt;&lt;&quot;Destructor of Date: &quot;&lt;&lt;year&lt;&lt;&quot;.&quot;&lt;&lt;month&lt;&lt;&quot;.&quot;&lt;&lt;day&lt;&lt;endl;
    &#125;
	int IsLeapYear();
    void Print()&#123;cout&lt;&lt;year&lt;&lt;&quot;.&quot;&lt;&lt;month&lt;&lt;&quot;.&quot;&lt;&lt;day&lt;&lt;endl;&#125;
&#125;
&#x2F;&#x2F;date.cpp
Date::Date(int y, int m, int d):year(y),month(m), day(d)&#123;
    cout&lt;&lt;&quot;Constructor of Date with 3 paramenters.&quot;&lt;&lt;endl;
&#125;
int Date::IsLeapYear()&#123;
	return (year%4&#x3D;&#x3D;0 &amp;&amp; year%100&#x3D; 0) || (year%400)&#x3D;&#x3D;0;
&#125;

&#x2F;&#x2F;example.cpp
#include“date.h”
int main()
&#123;
	Date date1(2022,4,8), date2; &#x2F;&#x2F;分别调用构造函数1，2
    cout&lt;&lt;&quot;date1:&quot;;
    date1.Print();
    cout&lt;&lt;&quot;date2:&quot;;
    date2.Print();
	if(date2.IsLeapYear())&#123;
        cout&lt;&lt;&quot;date2 is a leapyear.&quot;&lt;&lt;endl;
	else 
        cout&lt;&lt;&quot;date2 is not a leapyear. &quot;&lt;&lt;endl;
	return 0;
&#125;&#x2F;&#x2F;分别调用析构函数

&#x2F;*
Constructor of Date with 3 paramenters.
Constructor of Date with 1 paramenters.
date1: 2022.4.8
date2: 2000.4.8
date2 is leapyear.
Destructor of Date: 2000.4.8
Destructor of Date: 2022.4.8
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><blockquote><p>对象数组</p><ul><li>数组元素为对象的数组，即数组中每个元素都是同一个类的对象</li><li>对象数组的格式: <code>&lt;类名&gt;&lt;数组名&gt;[&lt;大小&gt;]…..</code> <code>DATE dates[5];</code><br>使用对象数组成员: <code>&lt;数组名&gt;[&lt;下标&gt;].&lt;成员名&gt;</code> <code>dates[0].year</code></li></ul></blockquote><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class DATE
&#123;
    int year, month, day;
  public:
	DATE():month(0), day(0), year(0)&#123;
		cout&lt;&lt;&quot;Default constructor called.&quot;&lt;&lt;endl;
	&#125;
	DATE(int m, int d, int y):month(m), day(d), year(y)&#123;
		cout&lt;&lt;&quot;Constructor called.&quot;&lt;&lt;day&lt;&lt;endl;
	&#125;
	~DATE()&#123;
		cout&lt;&lt;&quot;Destructor called.&quot;&lt;&lt;day&lt;&lt;endl;
	&#125;
	void Print() const&#123;
		cout&lt;&lt;&quot;Month&#x3D;&quot;&lt;&lt;month&lt;&lt;&quot;, Day&#x3D;&quot;&lt;&lt;day&lt;&lt;&quot;, Year&#x3D;&quot;&lt;&lt;year&lt;&lt;endl;
	&#125;
&#125;;
int main()&#123;
	DATE dates[5]&#x3D;&#123;DATE(10,1,2002),DATE(10,2,2002),DATE(10,3,2002)&#125;;
    dates[3] &#x3D; DATE(10,4,2002);
	dates[4] &#x3D; DATE(10,5,2002);
	for(int i&#x3D;0;i&lt;5;i++) dates[i].Print();
    return 0; 
&#125;

&#x2F;*
Constructor called.1
Constructor called.2
Constructor called.3
Default constructor called.
Default constructor called.
Constructor called.4
Destructor called.4 &#x2F;&#x2F;！
Constructor called.5 
Destructor called.5 &#x2F;&#x2F;！
Month &#x3D; 10, Day &#x3D; 1, Year &#x3D; 2002
Month &#x3D; 10, Day &#x3D; 2, Year &#x3D; 2002
Month &#x3D; 10, Day &#x3D; 3, Year &#x3D; 2002
Month &#x3D; 10, Day &#x3D; 4, Year &#x3D; 2002
Month &#x3D; 10, Day &#x3D; 5, Year &#x3D; 2002
Destructor called.5
Destructor called.4
Destructor called.3
Destructor called.2
Destructor called.1
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><blockquote><p>自由存储对象</p><ul><li>在程序运行过程中根据需要可以随时建立或者删除的对象称为自由存储对象（建立及删除可使用 new 和 delete）</li></ul></blockquote><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Class test&#123;
	int X, Y;
  public:
	Test();
	Test(int i, int j);
	~Test()&#123;cout&lt;&lt;“Destructor called: ”&lt;&lt; X &lt;&lt;“,”&lt;&lt; Y &lt;&lt; endl;&#125;
	void Set(int i, int j);
	void Print()&#123;cout&lt;&lt;  X &lt;&lt;“, ”&lt;&lt; Y &lt;&lt;endl;&#125;
&#125;;

Test::Test(): X(0), Y(0)&#123;
	cout&lt;&lt;“Default constructor called. ”&lt;&lt;endl;
&#125;;
Test::Test(int i, int j): X(i), Y(j)&#123;
	cout&lt;&lt;“Constructor called: ”&lt;&lt; X &lt;&lt;‘, ’&lt;&lt; Y &lt;&lt;endl;
&#125;;
void Test::Set(int i, int j)&#123;X&#x3D;i, Y&#x3D;j&#125;;

int main()&#123;
	Test *ptr1, *ptr2, *ptr3;
	ptr1 &#x3D; new Test(1, 2);
	ptr2 &#x3D; new Test(3, 4);
	ptr3 &#x3D; new Test[2];
	ptr3[0].Set(5, 6);
	ptr3[1].Set(7, 8);
	ptr1-&gt;Print();
	ptr2-&gt;Print();
	ptr3[0].Print();
	ptr3[1].Print();
	delete ptr1;
	delete ptr2;
	delete [] ptr3;
	return 0;
&#125;

&#x2F;*
Constructor called: 1, 2
Constructor called: 3, 4
Default constructor called.
Default constructor called.
1, 2
3, 4
5, 6
7, 8
Destructor called: 1, 2
Destructor called. 3, 4
Destructor called: 7, 8
Destructor called. 5, 6
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h4 id="3成员对象的初始化"><a class="anchor" href="#3成员对象的初始化">#</a> 3. 成员对象的初始化</h4><ul><li><p>成员对象：</p><p>对于类的数据成员，其类型可以是另一个类。也就是说，一个对象可以包含另一个对象（称为成员对象）</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123; 
    ...
&#125;;

class B&#123; 
    ...
	A a; &#x2F;&#x2F;成员对象
	...
&#125;;

B b; &#x2F;&#x2F;对象b包含一个成员对象：b.a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li><li><p>成员对象由成员对象类的构造函数初始化：</p><ul><li>如果在包含成员对象的类中，没有指出用成员对象类的什么构造函数对成员对象初始化，则调用成员对象类的默认构造函数。</li><li>可以在类构造函数的成员初始化表中显式指出用成员对象类的某个构造函数对成员对象初始化。</li></ul><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123; 
    int x;
  public:
	A() &#123; x &#x3D; 0; &#125;
	A(int i) &#123; x &#x3D; i; &#125;
&#125;;
class B&#123; 
    A a;
	int y;
  public:
	B(int i) &#123; y &#x3D; i;&#125; &#x2F;&#x2F;调用A的默认构造函数对a初始化。
	B(int i, int j): a(j) &#123; y &#x3D; i; &#125; &#x2F;&#x2F;调用A(int)对初始化。
&#125;;
B b1(1); &#x2F;&#x2F;b1.y初始化为1，b1.a.x初始化为0
B b2(1,2); &#x2F;&#x2F;b2.y初始化为1，b2.a.x初始化为2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li><li><p>创建包含成员对象的类的对象时，先执行成员对象类的构造函数，再执行本身类的构造函数。</p><ul><li><p>初始化成员对象时，若调用成员对象的非默认构造数，必用成员初始化列表</p></li><li><p>若成员初始化表为空，则调用成员对象的默认构造函数完成初始化</p></li><li><p>一个类若包含多个成员对象，这些对象的初始化次序按它们在类中的说明次序（而不是成员初始化表的次序）进行。</p></li></ul></li><li><p>析构函数的执行次序与构造函数的执行次序正好相反。</p><ul><li>先析构类对象，再析构成员对象</li><li>若有多个成员对象，则析构与构造次序相反</li></ul></li></ul><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Counter&#123;
	int val;
  Public:
	Counter(): val(0)&#123;cout&lt;&lt;“Defalut Constructor of Counter”&lt;&lt;endl;&#125;
	Counter(int x): val(x)&#123;cout&lt;&lt;“Constructor of 				Counter:”&lt;&lt;val&lt;&lt;endl;&#125;
	~Counter()&#123;cout&lt;&lt;“Destructor of Counter:”&lt;&lt;val&lt;&lt;endl;&#125;
&#125;;
class Example&#123;
	Counter c1, c2;
	int val;
  Public:
	Example(): val(0)&#123;cout&lt;&lt;“Defalut Constructor of Example”&lt;&lt;endl;&#125;
	Example(int x): c2(x),val(x)&#123;cout&lt;&lt;“Constructor of Example:”&lt;&lt;val&lt;&lt;endl;&#125;
	~Example()&#123;cout&lt;&lt;“Destructor of Example:”&lt;&lt;val&lt;&lt;endl;&#125;
	void Print() const &#123;cout&lt;&lt;“value &#x3D; ”&lt;&lt;val&lt;&lt;emdl;&#125;
&#125;;

int main()&#123;
	Example e1, e2(4);
	e2.Print();
	return 0;
&#125;

&#x2F;*
Defalut Constructor of Counter
Defalut Constructor of Counter
Defalut Constructor of Example
Defalut Constructor of Counter
Constructor of Counter: 4
Constructor of Example: 4
value&#x3D;4
Destructor of Example: 4
Destructor of Counter: 4
Destructor of Counter: 0
Destructor of Example: 0
Destructor of Counter: 0
Destructor of Counter: 0
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h4 id="4拷贝构造函数"><a class="anchor" href="#4拷贝构造函数">#</a> 4. 拷贝构造函数</h4><ul><li>在创建一个对象时，若用一个同类型的对象对其初始化，这时将会调用一个特殊的构造函数：拷贝构造函数。</li></ul><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123; 
    ......
  public:
	A(); &#x2F;&#x2F;默认构造函数
	A(const A&amp; a); &#x2F;&#x2F;拷贝构造函数 const可以省略，只是为了防止在函数体中修改实参对象
&#125;;

&#x2F;&#x2F;此外拷贝构造函数还可如下：
A(const A&amp; a， int i&#x3D;0, int j&#x3D;0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><ul><li><p>在三种情况下，会调用类的拷贝构造函数：</p><ul><li><p>定义对象时，例如：</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">A a1;
A a2(a1); &#x2F;&#x2F;也可写成：A a2&#x3D;a1; 或：A a2&#x3D;A(a1);
&#x2F;&#x2F;调用A的拷贝构造函数，用对象a1初始化对象a2，<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p></li><li><p>把对象作为值参数传给函数时，例如：</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void f(A x);
A a;
f(a); &#x2F;&#x2F;调用f时将创建形参对象x，并调用A的拷贝构造函数，用对象a对其初始化。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p></li><li><p>把对象作为函数的返回值时，例如：</p></li></ul><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">A f()&#123; 
    A a;
	......
	return a; &#x2F;&#x2F;创建一个A类的临时对象，并调用A的拷贝构造函数，用对象a对其初始化。
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li></ul><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;date.h
#include &lt;iostream&gt;
using namespace std;

class Date&#123;
		int year, month, day;
  public:
	Date(int y, int m, int d);
	Date(int y&#x3D;2000): year(y)&#123;
		month &#x3D; 4;
		day&#x3D;8;
		cout&lt;&lt;&quot;Constructor ofDate with 1 parameter.&quot;&lt;&lt;endl;
	&#125;
	Date(const Date&amp; d);
	~Date()&#123;cout&lt;&lt;&quot;Destructor of Date: &quot;&lt;&lt; year &lt;&lt;&quot;.&quot;&lt;&lt; month &lt;&lt;&quot;.&quot;&lt;&lt; day &lt;&lt; endl;&#125;
	int IsLeapYear();
	void Print()&#123;cout&lt;&lt;year&lt;&lt;&quot;.&quot;&lt;&lt;month&lt;&lt;&quot;.&quot;&lt;&lt;day&lt;&lt;endl;&#125;
&#125;;

&#x2F;&#x2F;date.cpp
Date::Date(int y, int m, int d): year(y),month(m),day(d)&#123;
	cout&lt;&lt;&quot;Constructor of Date with 3 paramenters.&quot;&lt;&lt;endl;
&#125;
Date::Date(const Date&amp; d)&#123;
	year&#x3D;d.year;
	month&#x3D;d.month;
	day&#x3D;d.day;
	cout&lt;&lt;&quot;Copy constructor of Date&quot;&lt;&lt;endl;
&#125;
int Date::IsLeapYear()&#123;
	return (year%4&#x3D;&#x3D;0 &amp;&amp; year%100 !&#x3D;0) || (year%400)&#x3D;&#x3D;0;
&#125;

Date fun(Date d)&#123;
	Date temp; temp&#x3D;d; return temp;
&#125;

int main()&#123;
	Date date1(2000, 1, 1), date2(0, 0, 0);
	Date date3(date1);
	date2&#x3D;fun(date3);
	cout&lt;&lt;&quot;date1: &quot;;
	date1.Print();
	cout&lt;&lt;&quot;date2: &quot;;
	date2.Print();
	cout&lt;&lt;&quot;date3: &quot;;
	date3.Print();
	return 0;
&#125;

&#x2F;*
Constructor of Date with 3 parameters.
Constructor of Date with 3 parameters.
Copy constructor of Date. &#x2F;&#x2F;date3(date1)
Copy constructor of Date. &#x2F;&#x2F;d(date3) !!!!! 调用方法fun()时
Constructor of Date with 1 parameters. &#x2F;&#x2F;(temp)
Copy constructor of Date.&#x2F;&#x2F;匿名date2(temp)
Destructor of Date: 2000.1.1&#x2F;&#x2F;temp对象
Destructor of Date: 2000.1.1 &#x2F;&#x2F;d对象
Destructor of Date: 2000.1.1 &#x2F;&#x2F;匿名对象
date1: 2000.1.1
date2: 2000.1.1
date3: 2000.1.1
Destructor of Date: 2000.1.1&#x2F;&#x2F;date3对象
Destructor of Date: 2000.1.1&#x2F;&#x2F;date2对象
Destructor of Date: 2000.1.1&#x2F;&#x2F;date1对象
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><ul><li>如果程序中没有为类提供拷贝构造函数，则编译器将会为其生成一个隐式拷贝构造函数。</li><li>隐式拷贝构造函数将逐个成员拷贝初始化：<ul><li>对于普通成员：它采用通常的初始化操作；</li><li>对于成员对象：则调用成员对象类的拷贝构造函数来实现成员对象的初始化 。</li></ul></li></ul><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123; 
    int x,y;
  public:
	A() &#123; x &#x3D; y &#x3D; 0; &#125;
	......
&#125;;
class B&#123; 
    int z;
	A a;
  public:
	B() &#123; z &#x3D; 0; &#125;
	...... &#x2F;&#x2F;其中没有定义拷贝构造函数
&#125;;
...
B b1; &#x2F;&#x2F;b1.z、b1.a.x以及b1.a.y均为0。
B b2(b1); &#x2F;&#x2F;b2.z初始化成b1.z；调用A的拷贝构造函数用b1.a对b2.a初始化。如果A中没有定义拷贝构造函数，则A的隐式拷贝构造函数把b2.a.x和b2.a.y分别初始化成 b1.a.x和b1.a.y；否则，由A的自定义拷贝构造函数决定如何对b2.a.x和b2.a.y进行初始化。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><ul><li><p>一般情况下，编译程序提供的默认拷贝构造函数的行为足以满足要求，类中不需要自定义拷贝构造函数。</p></li><li><p>在有些情况下必须要自定义拷贝构造函数，否则，将会产生设计者未意识到的严重的程序错误：</p><ul><li><p>浅拷贝</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123; 
    int x,y;
	char *p;
  public:
	A(char *str)&#123; 
        x &#x3D; 0; y &#x3D; 0;
		p &#x3D; new char[strlen(str)+1];
		strcpy(p,str);
	&#125;
	~A() &#123; delete [] p; p&#x3D;NULL; &#125;
&#125;;
......
A a1(“abcd”);
A a2(a1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p><img data-src="https://cdn.jsdelivr.net/gh/rainnn-w/Pictures@main/blog/202308281110027.png" alt="image-20230530140234188"></p><p>系统提供的隐式拷贝构造函数将会使得 a1 和 a2 的成员指针 p 指向同一块内存区域！</p><blockquote><ul><li>如果对一个对象操作之后修改了这块空间的内容，则另一个对象将会受到影响。如果不是设计者特意所为，这将是一个隐藏的错误。</li><li>当对象 a1 和 a2 消亡时，将会分别去调用它们的析构函数，<br>这会使得同一块内存区域将被归还两次，从而导致程<br>序运行异常。</li></ul></blockquote></li><li><p>深拷贝</p><p>解决上面问题的办法是在类 A 中显式定义一个拷贝构造函数。</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">A::A(const A&amp; a)&#123; 
    x &#x3D; a.x;
	y &#x3D; a.y;
	p &#x3D; new char[strlen(a.p)+1];
	strcpy(p,a.p);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p><img data-src="https://cdn.jsdelivr.net/gh/rainnn-w/Pictures@main/blog/202308281110527.png" alt="image-20230530140326030"></p></li></ul></li><li><p>隐式拷贝构造函数会调用成员对象的拷贝构造函数</p></li><li><p>自定义的拷贝构造函数将默认调用成员对象类的默认构造函数对成员对象初始化！</p></li></ul><h3 id="五-进阶"><a class="anchor" href="#五-进阶">#</a> （五） 进阶</h3><h4 id="1常const成员函数"><a class="anchor" href="#1常const成员函数">#</a> 1. 常 (const) 成员函数</h4><h5 id="1常成员函数"><a class="anchor" href="#1常成员函数">#</a> （1）常成员函数</h5><ul><li><p>为了防止在获取对象状态的成员函数中改变对象的状态，可以把它们说明成 ** <code>const</code> 成员函数 **。</p></li><li><p>声明与定义时都应加上 <code>const</code></p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Date&#123; 
  public:
	void set(int y, int m, int d); &#x2F;&#x2F;改变对象状态
	int get_day() const; &#x2F;&#x2F;获取对象状态
&#125;;
int Date::get_day() const &#123;.....&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li><li><p><code>const</code> 成员函数不能改变对象的状态（数据成员的值）。</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123; 
    int x;
	char *p;
  public:
	......
	void f() const&#123;
		x &#x3D; 10; &#x2F;&#x2F;Error
		p &#x3D; new char[20]; &#x2F;&#x2F;Error
		strcpy(p,&quot;ABCD&quot;); &#x2F;&#x2F;没有改变p的值，编译程序认为OK！
	&#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li><li><p>给成员函数加上 const 修饰符还有一个作用：描述对常量对象所能进行的操作（常对象只能调用常成员函数）。</p></li><li><p>常成员函数不能调用非常成员函数。</p></li></ul><blockquote><p>const 成员函数可以修改 static 成员变量<br>✓ const 修饰 this 指针指向内容不可更改<br>✓ static 变量不用 this 指针访问</p><p>const 成员函数不能修改对象的任何数据成员</p></blockquote><h5 id="2常对象"><a class="anchor" href="#2常对象">#</a> （2）常对象</h5><ul><li><p>使用 const 关键字修饰的对象称为<strong>常对象</strong> <code>&lt;类名&gt; const &lt;对象名&gt;</code> 或者 <code>const &lt;类名&gt; &lt;对象名&gt;</code></p></li><li><p><strong>常数据成员</strong>： <code>const</code> 说明的数据成员，只能通过构造函数的成员初始化列表显式进行初始化</p></li><li><p>注意：</p><ul><li><p>常对象在<strong>定义时</strong>必须进行<strong>初始化</strong>，而且不能被更新</p></li><li><p>常对象只能调用它的常成员函数</p></li><li><p>一般对象既可以调用常成员函数，也可以调用一般成员函数</p></li><li><p>对于成员函数，<strong> <code>const</code> 参与函数重载的区分</strong></p><p>常对象调用常成员函数，一般对象调用一般成员函数</p></li><li><p>常成员函数可以直接访问类的常数据成员及一般数据成员</p></li></ul></li></ul><h4 id="2静态数据成员"><a class="anchor" href="#2静态数据成员">#</a> 2. 静态数据成员</h4><h5 id="1静态数据成员"><a class="anchor" href="#1静态数据成员">#</a> （1）静态数据成员</h5><ul><li>可通过静态数据成员来实现属于同一个类的不同对象之间的数据共享</li><li>类的静态数据成员对该类的所有对象只有一个拷贝。</li><li>往往在类的外部给出定义并进行初始化。在函数内部声明。</li><li>需要通过对象来访问。 <code>a.x</code></li></ul><h5 id="2静态成员函数"><a class="anchor" href="#2静态成员函数">#</a> （2）静态成员函数</h5><ul><li><p>静态成员函数可以通过对象来访问外，也可以直接通过类来访问。 <code>A::get_shared();</code> 或 <code>A a; a.get_shared();</code></p></li><li><p>静态成员函数可以直接访问类的静态成员</p></li><li><p>静态成员函数不能直接访问类的非静态成员</p><blockquote><p>静态成员函数没有隐藏的 this 参数</p></blockquote></li><li><p>若要访问非静态成员，必须通过参数传递的方式得到相应的对象，再通过对象进行访问</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123; 
    int x,y;
	static int shared;
  public:
	A() &#123; x &#x3D; y &#x3D; 0; &#125;
	......
	static int get_shared(A&amp; a) &#123; return shared; &#125;
	......
	int A::get_shared(A&amp; a)&#123;
	......a.x......a.y
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li></ul><h4 id="3友元friend"><a class="anchor" href="#3友元friend">#</a> 3. 友元 (friend)</h4><ul><li>指定与一个类密切相关的、又不适合作为该类成员的程序实体（某些全局函数、某些其它类或某些其它类的某些成员函数）<strong>可以直接访问该类的 private 和 protected 成员</strong>。这些程序实体称为该类的友元。</li></ul><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123; 
    ......
	friend void func(); &#x2F;&#x2F;友元函数，可访问x
	friend class B; &#x2F;&#x2F;友元类，可访问x 类B中的所有成员函数都可以访问A类中的成员
	friend void C::f(); &#x2F;&#x2F;友元类成员函数，可访问x
  private:
	int x;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><ul><li>友元关系具有不对称性，不具有传递性，友元关系不能被继承。</li><li>友元是数据保护和数据访问效率之间的一种折中方案。（破坏了类的封装性）</li><li>一个类的友元函数不属于这个类。</li></ul><h4 id="4转移构造函数"><a class="anchor" href="#4转移构造函数">#</a> 4. 转移构造函数</h4><h4 id="5操作符重载"><a class="anchor" href="#5操作符重载">#</a> 5. 操作符重载</h4><h5 id="1概述"><a class="anchor" href="#1概述">#</a> （1）概述</h5><ul><li><p>操作符重载实质上是函数重载</p></li><li><p>可以重载 C++ 中除下列操作符外的所有操作符：<br>成员选择符 <code>.</code> ，间接成员选择符 <code>.*</code> <code>-&gt;*</code> ，条件操作符 <code>?:</code> ，域解析符 <code>::</code> ， <code>sizeof</code></p></li><li><p>重载操作符时，其操作数中至少应该有一个是类、结构、枚举以及它们的引用类型。</p></li><li><p>操作符重载可通过下面两个途径来实现：</p><ul><li><p>作为一个类的非静态的成员函数（ <code>new</code> 和 <code>delete</code> 除外）。</p></li><li><p>作为一个全局（友元）函数。</p></li></ul></li><li><p>一般情况下，操作符既可以作为全局函数，也可以作为成员函数来重载。</p></li><li><p>在有些情况下，操作符只能作为全局函数或只能作为成员函数来重载。</p></li></ul><h5 id="2双目操作符重载"><a class="anchor" href="#2双目操作符重载">#</a> （2）双目操作符重载</h5><p>① 作为成员函数重载</p><ul><li><p>重载函数的声明格式</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class &lt;类名&gt;
&#123; ......
&lt;返回值类型&gt; operator # (&lt;类型&gt;); &#x2F;&#x2F;#代表可重载的操作符
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p></li><li><p>重载函数的定义格式</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&lt;返回值类型&gt; &lt;类名&gt;::operator # (&lt;类型&gt; &lt;参数&gt;) &#123; ...... &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p></li><li><p>使用格式</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&lt;类名&gt; a;
&lt;类型&gt; b;
a # b
或
a.operator#(b)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li></ul><p>例：</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Complex&#123; 
    double real, imag;
public:
......
	bool operator &#x3D;&#x3D;(const Complex&amp; x) const&#123; 
    	return (real &#x3D;&#x3D; x.real) &amp;&amp; (imag &#x3D;&#x3D; x.imag);
	&#125;
	bool operator !&#x3D;(const Complex&amp; x) const&#123; 
   		return (real !&#x3D; x.real) || (imag !&#x3D; x.imag);
	&#125;
&#125;;
......
Complex c1,c2;
......
if (c1 &#x3D;&#x3D; c2) &#x2F;&#x2F; 或 if (c1 !&#x3D; c2)
......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>② 作为全局（友元）函数重载</p><ul><li><p>定义格式</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&lt;返回值类型&gt; operator #(&lt;类型1&gt; &lt;参数1&gt;,&lt;类型2&gt; &lt;参数2&gt;)
&#123; ...... &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p></li><li><p>使用格式：</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&lt;类型1&gt; a;
&lt;类型2&gt; b;
a # b 或 operator#(a,b)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p></li></ul><p>例：</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Complex&#123; 
    double real, imag;
public:
	Complex() &#123; real &#x3D; 0; imag &#x3D; 0; &#125;
	Complex(double r, double i) &#123; real &#x3D; r; imag &#x3D; i; &#125;
......
	friend Complex operator + (const Complex&amp; c1,const Complex&amp; c2);
	friend Complex operator + (const Complex&amp; c,double d);
	friend Complex operator + (double d,const Complex&amp; c);
&#125;;

Complex operator + (const Complex&amp; c1,const Complex&amp; c2)&#123; 
    return Complex(c1.real+c2.real,c1.imag+c2.imag);
&#125;
Complex operator + (const Complex&amp; c, double d)&#123; 
    return Complex(c.real+d,c.imag);
&#125;
&#x2F;&#x2F;只能作为全局函数重载,若使用成员函数不符合显式调用（操作符重载本质）
Complex operator + (double d, const Complex&amp; c)&#123; 
    return Complex(d+c.real,c.imag);
&#125;
......
Complex a(1,2),b(3,4),c1,c2,c3;
c1 &#x3D; a + b;
c2 &#x3D; b + 21.5;
c3 &#x3D; 10.2 + a;   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><blockquote><p>表达式 x=operator-(y,z) 还可以表示为 x=y-z</p></blockquote><h5 id="3单目操作符重载"><a class="anchor" href="#3单目操作符重载">#</a> （3）单目操作符重载</h5><p>①作为成员函数重载</p><ul><li><p>定义格式</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class &lt;类名&gt;
&#123; ......
&lt;返回值类型&gt; operator # ();
&#125;;
&lt;返回值类型&gt; &lt;类名&gt;::operator # () &#123; ...... &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li><li><p>使用格式</p></li></ul><p><code>&lt;类名&gt; a; #a</code> 或 <code>a.operator#()</code></p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Complex&#123; 
    ......
  public:
	......
	Complex operator -() const&#123; 
        Complex temp;
		temp .real &#x3D; -real;
		temp.imag &#x3D; -imag;
		return temp;
	&#125;
&#125;;
......
Complex a(1,2),b;
b &#x3D; -a; &#x2F;&#x2F;把b修改成a的负数。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>②作为全局（友元）函数重载</p><ul><li><p>定义格式</p><p><code>&lt;返回值类型&gt; operator #(&lt;类型&gt; &lt;参数&gt;) &#123; ...... &#125;</code></p></li><li><p>使用格式</p><p><code>&lt;类型&gt; a; #a</code> 或 <code>operator#(a)</code></p></li></ul><h6 id="操作符和-的重载"><a class="anchor" href="#操作符和-的重载">#</a> 操作符 ++ 和 -- 的重载</h6><ul><li><p>操作符 ++（--）有前置和后置两种用法：</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int x&#x3D;0;
++x; x++; &#x2F;&#x2F;OK
++(++x); (++x)++; &#x2F;&#x2F;OK，++x为左值表达式
++(x++); (x++)++; &#x2F;&#x2F;Error，x++为右值表达式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p></li><li><pre><code class="language-c++">class Counter&#123; 
    int value;
  public:
	Counter() &#123; value = 0; &#125;
	Counter&amp; operator ++()&#123; //前置的++重载函数
    	value++;
	  	return *this;
	&#125;
	const Counter operator ++(int)&#123; //后置的++重载函数
 		Counter temp=*this; //保存原来的对象
		value++; //写成：++(*this);更好！调用前置的++重载函数
		return temp; //返回原来的对象
	&#125;
&#125;;
Counter a,b,c;
b = ++a; //使用的是上述类定义中不带参数的操作符++重载函数
c = a++; //使用的是上述类定义中带int型参数的操作符++重载函数
++(++a); (++a)++; //OK
++(a++); (a++)++; //Error
<pre class="line-numbers language-none"><code class="language-none">
##### （4）特殊操作符的重载

###### ①赋值操作符“&#x3D;”的重载

- C++编译程序会为每个类定义一个隐式的赋值操作符重载函数，其行为是：逐个成员进行赋值操作

- 参照浅拷贝，解决上面问题的办法是自己定义赋值操作符重载函数

&#96;&#96;&#96;c++
class A&#123; 
    ......
	A&amp; operator &#x3D; (const A&amp; a)&#123;&#x2F;&#x2F;返回值应声明为引用
 		if (&amp;a &#x3D;&#x3D; this) return *this; &#x2F;&#x2F;防止自身赋值。
		delete []p;&#x2F;&#x2F;如果被赋值对象占用了动态空间，应先释放，后接收
		p &#x3D; new char[strlen(a.p)+1];
		strcpy(p,a.p);
		x &#x3D; a.x; y &#x3D; a.y;
		return *this;
	&#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</code></pre></li><li><p>自定义的赋值操作符重载函数不会自动地去进行成员对象的赋值操作，必须要在自定义的赋值操作符重载函数中显式地指出。</p></li><li><p>赋值操作符只能作为非静态的成员函数来重载。</p><blockquote><p>若使用全局函数，则会与隐式赋值操作符重载函数存在歧义</p></blockquote></li><li><p>一般来讲，需要自定义拷贝构造函数的类通常也需要自定义赋值操作符重载函数。</p></li></ul><h6 id="2访问数组元素操作符-的重载"><a class="anchor" href="#2访问数组元素操作符-的重载">#</a> ②访问数组元素操作符 “[]” 的重载</h6><ul><li>对于由具有线性关系的元素所构成的对象，可通过重载 “[]”，实现对其元素的访问。</li></ul><h6 id="3重载操作符new"><a class="anchor" href="#3重载操作符new">#</a> ③重载操作符 new</h6><ul><li><p>操作符 <code>new</code> 必须作为静态的成员函数来重载（ <code>static</code> 说明可以不写）</p><p><code>void *operator new(size_t size);</code></p><ul><li>返回类型必须为 <code>void *</code></li><li>参数表示对象所需空间的大小，其类型为 size_t (unsigned int)</li><li>new 重载函数可以有多个（参数需有所不同）</li></ul></li><li><p>重载 new 时，除了对象空间大小参数以外，也可以带有其它参数</p><p><code>void *operator new(size_t size,XXX);</code></p><p>使用格式： <code>p = new (XXX) A(...);</code></p></li></ul><h6 id="4重载操作符delete"><a class="anchor" href="#4重载操作符delete">#</a> ④重载操作符 delete</h6><ul><li><p>与重载操作符 new 相同</p></li><li><p>操作符 delete 也必须作为静态的成员函数来重载（ <code>static</code> 说明可以不写）</p></li><li><p>delete 重载函数只能有一个</p></li></ul><h6 id="5函数调用操作符"><a class="anchor" href="#5函数调用操作符">#</a> ⑤函数调用操作符 “()”</h6><h6 id="6类成员访问操作符-的重载"><a class="anchor" href="#6类成员访问操作符-的重载">#</a> ⑥类成员访问操作符 “-&gt;” 的重载</h6><ul><li><p>“-&gt;” 为一个双目操作符，其第一个操作数为一个指向类或结构的指针，第二个操作数为第一个操作数所指向的类或结构的成员。</p></li><li><p>通过对 “-&gt;” 进行重载，可以实现一种<strong>智能指针</strong>（smart pointers）：</p><p>一个具有指针功能的对象，通过该对象访问所 “指向” 的另一个对象时，在访问所指向对象的成员前能做一些额外的事情。</p><p>智能指针 (smart pointer) 是存储指向动态分配（堆）对象指针的类，用于生存期控制，能够确保自动正确的销毁动态分配的对象，防止内存泄露（利用自动调用类的析构函数来释放内存）。</p><blockquote><p>必用成员函数重载</p></blockquote></li></ul><h6 id="7带一个参数的构造函数"><a class="anchor" href="#7带一个参数的构造函数">#</a> ⑦带<strong>一个参数</strong>的构造函数</h6><ul><li>带<strong>一个参数</strong>的构造函数可以用作从一个基本数据类型或其它类到某个类的转换。</li></ul><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Complex&#123; 
    double real, imag;
  public:
	Complex() &#123; real &#x3D; 0; imag &#x3D; 0; &#125;
	Complex(double r) &#123; real &#x3D; r; imag &#x3D; 0; &#125;
	Complex(double r, double i) &#123; real &#x3D; r; imag &#x3D; i; &#125;
	......
	friend Complex operator + (const Complex&amp; x, const Complex&amp; y);
&#125;;
......
Complex c1(1,2),c2,c3;
c2 &#x3D; c1 + 1.7; &#x2F;&#x2F;1.7隐式转换成一个复数对象Complex(1.7)
c3 &#x3D; 2.5 + c2; &#x2F;&#x2F;2.5隐式转换成一个复数对象Complex(2.5)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h6 id="8自定义类型转换"><a class="anchor" href="#8自定义类型转换">#</a> ⑧自定义类型转换</h6><ul><li><p>自定义类型转换，从一个类转换成基本数据类型或其它类（不需要返回值类型的声明）</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123; 
    int x,y;
  public:
	......
	operator int() &#123; return x+y; &#125; &#x2F;&#x2F;类型转换操作符int的重载函数
&#125;;
......
A a;
int i&#x3D;1;
int z &#x3D; i + a; &#x2F;&#x2F;将调用类型转换操作符int的重载函数把对象a隐式转换成int型数据。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li></ul><h2 id="七-继承类的复用-派生类"><a class="anchor" href="#七-继承类的复用-派生类">#</a> 七、继承（类的复用）---- 派生类</h2><h3 id="一概述"><a class="anchor" href="#一概述">#</a> （一）概述</h3><h4 id="1继承关系"><a class="anchor" href="#1继承关系">#</a> 1. 继承关系</h4><ul><li>在继承关系中存在两个类：基类（或称父类）和派生类（或称子类）。</li><li>派生类拥有基类的所有特征，并可以<ul><li>定义新的特征</li><li>或对基类的一些特征进行重定义。</li></ul></li></ul><h3 id="二单继承"><a class="anchor" href="#二单继承">#</a> （二）单继承</h3><blockquote><p>单继承时，派生类只能有一个直接基类</p></blockquote><h4 id="1单继承派生类的定义"><a class="anchor" href="#1单继承派生类的定义">#</a> 1. 单继承派生类的定义：</h4><ul><li>定义：</li></ul><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class &lt;派生类名&gt;：[&lt;继承方式&gt;] &lt;基类名&gt;
&#123; &lt;成员说明表&gt;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><p>&lt;继承方式&gt; 指出对从基类继承来的成员的访问控制，可以是 <code>public</code> <code>private</code> <code>protected</code></p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A &#123;&#x2F;&#x2F;基类
 	int x,y;
  public:
	void f();
	void g();
&#125;;
class B: public A &#123;&#x2F;&#x2F;派生类
 	int z; &#x2F;&#x2F;新成员
  public:
	void h(); &#x2F;&#x2F;新成员
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><ul><li><p>派生类除了拥有新定义的成员外，还拥有基类的所有成员（除了基类的构造 / 析构函数和赋值操作符重载函数）</p></li><li><p>定义派生类时一定要见到基类的定义。</p></li><li><p>如果在派生类中没有显式说明，基类的友元不是派生类的友元；如果基类是另一个类的友元，而该类没有显式说明，则派生类也不是该类的友元。</p></li></ul><h4 id="2访问基类成员"><a class="anchor" href="#2访问基类成员">#</a> 2. 访问基类成员</h4><ul><li>派生类不能直接访问基类的私有成员。</li><li><code>protected</code> 用它说明的成员<strong>不能通过对象使用</strong>，但可以在派生类中使用。</li></ul><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A &#123; &#x2F;&#x2F;基类
	int x,y;
  public:
	void f();
	void g();
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><ul><li><p>派生类对基类成员的访问除了受到基类的访问控制的限制以外，还要受到标识符作用域的限制。</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class B: public A&#123; 
    int z;
  public:
	void f();
	void h()&#123; 
        f(); &#x2F;&#x2F;B类中的f
		A::f(); &#x2F;&#x2F;A类中的f
	&#125;
&#125;;
B b;
b.f(); &#x2F;&#x2F;B类中的f
b.A::f(); &#x2F;&#x2F;A类中的f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li><li><p>即使派生类中定义了与基类同名但参数不同的成员函数，<strong>基类的同名函数在派生类的作用域中也是不直接可见的</strong>，可以用基类名受限方式来使用之</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class B: public A&#123; 
    int z;
  public:
	void f(int); &#x2F;&#x2F;不是重载A的f！
	void h()&#123; 
        f(1); &#x2F;&#x2F;OK
		f(); &#x2F;&#x2F;Error
		A::f(); &#x2F;&#x2F;OK
	&#125;
&#125;;
......
B b;
b.f(1); &#x2F;&#x2F;OK
b.f(); &#x2F;&#x2F;Error
b.A::f(); &#x2F;&#x2F;OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li><li><p>也可以在派生类中使用 using 声明把基类中某个的函数名对派生类开放</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class B: public A&#123; 
    int z;
  public:
	using A::f;
	void f(int); &#x2F;&#x2F;不是重载A的f！
	void h()&#123; 
        f(1); &#x2F;&#x2F;OK
		f(); &#x2F;&#x2F;OK，等价于A::f();
	&#125;
&#125;;
......
B b;
b.f(1); &#x2F;&#x2F;OK
b.f(); &#x2F;&#x2F;OK，等价于b.A::f();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li></ul><h4 id="3继承方式"><a class="anchor" href="#3继承方式">#</a> 3. 继承方式</h4><ul><li>默认的继承方式为： <code>private</code></li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/rainnn-w/Pictures@main/blog/202308281110141.png" alt="img"></p><ul><li><p>可在派生类中分别调整基类各成员的访问控制属性（基类 private 成员除外）</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123;
  public:
	void f1();
  protected:
	void g1();
&#125;;

class B: private A&#123;
  public:
	A::f1;&#x2F;&#x2F;f1调整为public
	A::g1;&#x2F;&#x2F;g1调整为public
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li><li><p>可以将派生类对象赋值给基类对象</p><p>可以将派生类对象的地址赋值给基类指针</p><p>可以将派生类对象赋值给基类的引用</p></li><li><p>派生类对象不能赋值给派生类对象。</p><p>派生类指针变量不能指向基类对象。</p><p>派生类操作不能用于基类对象。</p></li></ul><h4 id="4初始化和赋值操作"><a class="anchor" href="#4初始化和赋值操作">#</a> 4. 初始化和赋值操作</h4><h5 id="1初始化"><a class="anchor" href="#1初始化">#</a> ①初始化</h5><ul><li><p>派生类构造函数必须负责<strong>调用基类构造函数</strong>，并对其所需要的参数进行设置</p></li><li><p>派生类对象的初始化由基类和派生类共同完成：</p><ul><li>基类的数据成员由基类的构造函数初始化</li><li>派生类的数据成员由派生类的构造函数初始化</li></ul></li><li><p>当创建派生类的对象时：</p><ul><li><strong>先执行基类的构造函数，再执行派生类构造函数</strong>。</li><li>默认情况下，调用基类的默认构造函数，如果要调用基类的<strong>非默认构造函数</strong>，则必须在派生类构造函数的<strong>成员初始化表</strong>中指出。</li></ul></li><li><p>如果一个类 D 既有基类 B、又有成员对象类 M：</p><ul><li>在创建 D 类对象时，构造函数的执行次序为：<br>B（调用顺序按照各个基类被继承时声明的顺序）-&gt;M-&gt;D 类构造函数体</li><li>当 D 类的对象消亡时，析构函数的执行次序为：D-&gt;M-&gt;B</li></ul></li><li><p>对于拷贝构造函数：</p><ul><li>派生类的<strong>隐式</strong>拷贝构造函数（由编译程序提供）将会调用<strong>基类的拷贝构造函数</strong>。</li><li>派生类自定义的拷贝构造函数在默认情况下则调用基类的<strong>默认构造函数</strong>。需要时，可在派生类自定义拷贝构造函数的 “基类 / 成员初始化表” 中显式地指出调用<strong>基类的拷贝构造函数</strong>。</li></ul></li></ul><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123; 
    int a;
  public:
	A() &#123; a &#x3D; 0; &#125;
	A(const A&amp; x) &#123; a &#x3D; x.a; &#125;
	......
&#125;;
class B: public A&#123; 
  public:
	B() &#123; ...... &#125; 
    ...... &#x2F;&#x2F;没有定义拷贝构造，需要时用隐式拷贝构造
&#125;;
	
class C: public A&#123; 
  public:
	C() &#123;......&#125;
	C(const C&amp; ) &#123; ...... &#125; &#x2F;&#x2F;调用A的默认构造
	......
&#125;;
class D: public A&#123; 
  public:
	D() &#123;......&#125;
	D(const D&amp; d): A(d) &#123; ...... &#125; &#x2F;&#x2F;显式指定调用A的拷贝构造
	......
&#125;;

B b1;&#x2F;&#x2F;调用A()
B b2(b1); &#x2F;&#x2F;调用A的拷贝构造
C c1;&#x2F;&#x2F;调用A()
C c2(c1);&#x2F;&#x2F;调用A的默认构造函数A()
D d1;&#x2F;&#x2F;调用A()
D d2(d1);&#x2F;&#x2F;调用A的拷贝构造<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h5 id="2赋值"><a class="anchor" href="#2赋值">#</a> ②赋值</h5><ul><li><p>如果派生类没有提供赋值操作符重载，则系统会为它提供一个<strong>隐式的赋值操作符重载函数</strong>，其行为是：</p><ul><li>对基类成员调用基类的赋值操作进行赋值，</li><li>对派生类的成员按逐个成员赋值。</li></ul></li><li><p>派生类<strong>自定义</strong>的赋值操作符重载函数<strong>不会自动调用基类的赋值操作</strong>，需要<strong>显式地调用基类的赋值操作符</strong>来实现基类成员的赋值。</p></li><li><p>派生类不从基类继承赋值操作</p></li></ul><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123; 
    ......
&#125;;
class B: public A&#123; 
    ......
  public:
	B&amp; operator &#x3D;(const B&amp; b)&#123; 
        if (&amp;b &#x3D;&#x3D; this) return *this; &#x2F;&#x2F;防止自身赋值。
		*(A*)this &#x3D; b; &#x2F;&#x2F;调用基类的赋值操作符对基类成员进行赋值。也可写成：this-&gt;A::operator &#x3D;(b);
		...... &#x2F;&#x2F;对派生类的成员赋值
		return *this;
	&#125;
&#125;;
......
B b1,b2;
b1 &#x3D; b2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h5 id="3聚集"><a class="anchor" href="#3聚集">#</a> ③聚集</h5><ul><li>继承不是代码复用的唯一方式，有些代码复用不宜用继承来实现。</li><li>类之间还存在一种聚集（aggregation，也称聚合）关系：<ul><li>一个类作为另一个类的成员对象类。</li><li>具有聚集关系的两个类之间属于部分与整体的关系（is-a-part-of）</li></ul></li></ul><h5 id="4子类型"><a class="anchor" href="#4子类型">#</a> ④子类型</h5><ul><li>子类型关系可以传递，但是不可逆</li></ul><h3 id="三消息成员函数调用的动态绑定"><a class="anchor" href="#三消息成员函数调用的动态绑定">#</a> （三）消息（成员函数调用）的动态绑定</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123; 
    int x,y;
  public:
	void f();
&#125;;
class B: public A&#123; 
    int z;
  public:
	void f(); 
	void g();
&#125;;
void func1(A&amp; x)&#123; 
    ......
	x.f(); &#x2F;&#x2F;调用A::f
	......
&#125;
void func2(A *p)&#123; 
    ......
	p-&gt;f(); &#x2F;&#x2F;调用A::f
	......
&#125;
......
A a;
func1(a);
func2(&amp;a);
B b;
func1(b);
func2(&amp;b);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h4 id="1静态绑定"><a class="anchor" href="#1静态绑定">#</a> 1. 静态绑定</h4><ul><li>默认静态绑定</li></ul><h4 id="2动态绑定"><a class="anchor" href="#2动态绑定">#</a> 2. 动态绑定</h4><ul><li>一般情况下，需要在 func1（或 func2）中根据 x（或 p）实际引用（或指向）的对象来决定是调用 <code>A::f</code> 还是 <code>B::f</code> 。即，采用动态绑定。在 C++ 中用虚函数来实现动态绑定。</li></ul><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123; 
    int x,y;
  public:
	virtual void f(); &#x2F;&#x2F;虚函数
&#125;;
class B: public A&#123; 
    int z;
  public:
	void f();&#x2F;&#x2F;仍为虚函数，在其派生类中可被再次重写
	void g();
&#125;;
void func1(A&amp; x)&#123; 
    ......
	x.f(); 
	......
&#125;
void func2(A *p)&#123; 
    ......
	p-&gt;f(); 
	......
&#125;
A a;
func1(a); &#x2F;&#x2F;在func1中调用A::f
func2(&amp;a); &#x2F;&#x2F;在func2中调用A::f
B b;
func1(b); &#x2F;&#x2F;在func1中调用B::f
func2(&amp;b); &#x2F;&#x2F;在func2中调用B::f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><ul><li><p>基类中的一个成员函数如果被定义成虚函数，则在派生类中定义的、与之具有<strong>相同型构</strong>的成员函数是对基类该成员函数的<strong>重定义</strong>（或称<strong>覆盖</strong>，override）</p><blockquote><p><strong>相同的型构</strong>是指：派生类中定义的成员函数的<strong>名字、参数类型和个数</strong>与基类相应成员函数相同，其<strong>返回值类型</strong>与基类成员函数返回值类型或者<strong>相同</strong>，或者是基类成员函数返回值类型的<strong>派生类</strong>。</p></blockquote></li><li><p>一旦在基类中指定某成员函数为虚函数，那么，不管在派生类中是否给出 <code>virtual</code> 声明，派生类（以及派生类的派生类...）中与其有相同型构的成员函数均为虚函数。</p></li><li><p>只有类的成员函数才可以是虚函数，但<strong>静态成员函数不能是虚函数</strong>。</p></li><li><p><strong>构造函数不能是虚函数</strong>，析构函数可以（往往）是虚函数。</p></li><li><p>只有通过基类的指针或引用访问基类的虚函数时才进行动态绑定。</p></li><li><p>基类的构造函数中对虚函数的调用不进行动态绑定。</p></li></ul><p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class A&#123;                                                  
  public:
	A() &#123; f();&#125;
	~A();
	virtual void f();
	void g();
	void h() &#123; f(); g(); &#125;
&#125;;
class B: public A&#123; 
  public:
	~B();
	void f();
	void g();
&#125;;
......
A a; &#x2F;&#x2F;调用A::A()和A::f
a.f(); &#x2F;&#x2F;调用A::f
a.g(); &#x2F;&#x2F;调用A::g
a.h(); &#x2F;&#x2F;调用A::h、A::f和A::g
B b; &#x2F;&#x2F;调用B::B(), A::A() 和 A::f !!!
b.f(); &#x2F;&#x2F;调用B::f
b.g(); &#x2F;&#x2F;调用B::g !!!!
b.h(); &#x2F;&#x2F;调用A::h、B::f 和 A::g !!!

A *p;
p &#x3D; &amp;a;
p-&gt;f(); &#x2F;&#x2F;调用A::f
p-&gt;g(); &#x2F;&#x2F;调用A::g
p-&gt;h(); &#x2F;&#x2F;调用A::h, A::f和A::g
p &#x3D; &amp;b;
p-&gt;f(); &#x2F;&#x2F;调用B::f
p-&gt;A::f(); &#x2F;&#x2F;调用A::f
p-&gt;g(); &#x2F;&#x2F;调用A::g，对非虚函数的调用采用静态绑定。 !!!
p-&gt;h(); &#x2F;&#x2F;调用A::h, B::f和A::g
p &#x3D; new B; &#x2F;&#x2F;调用B::B(), A::A()和A::f !!!
.......
delete p; &#x2F;&#x2F;调用A::~A()，因为没有把A的析构函数定义为虚函数。 !!!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h4 id="3纯虚函数和抽象类"><a class="anchor" href="#3纯虚函数和抽象类">#</a> 3. 纯虚函数和抽象类</h4><ul><li><p><strong>纯虚函数</strong>是指函数体为空（=0）的虚函数</p><p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class A&#123; 
    ......
  public:
	virtual int f()&#x3D;0; &#x2F;&#x2F;纯虚函数
	......
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li><li><p>包含纯虚函数的类称为<strong>抽象类</strong></p></li><li><p>抽象类不能用于创建对象。</p></li><li><p>抽象类的作用是为派生类提供一个基本框架和一个公共的对外接口</p></li></ul><h3 id="四-多继承"><a class="anchor" href="#四-多继承">#</a> （四） 多继承</h3><ul><li>多继承是指派生类可以有一个以上的直接基类。</li></ul><h4 id="1定义-7"><a class="anchor" href="#1定义-7">#</a> 1. 定义</h4><ul><li>定义格式：</li></ul><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class &lt;派生类名&gt;： [&lt;继承方式&gt;] &lt;基类名1&gt;，[&lt;继承方式&gt;] &lt;基类名2&gt;，...
&#123; 
    &lt;成员说明表&gt;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><ul><li>继承方式及访问控制的规定同单继承。<ul><li>派生类拥有所有基类的所有成员。</li><li>基类的声明次序决定：<ul><li>对基类构造函数 / 析构函数的调用次序</li><li>对基类数据成员的存储安排。</li></ul></li></ul></li></ul><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class C: public A, public B
&#123; 
    ......
&#125;;
&#x2F;&#x2F;构造函数的执行次序是：A()、B()、C()
&#x2F;&#x2F;（A()和B()实际是在C()的成员初始化表中调用。）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h4 id="2命名冲突"><a class="anchor" href="#2命名冲突">#</a> 2. 命名冲突</h4><ul><li>解决方法：基类名受限</li></ul><h4 id="3重复继承-虚基类"><a class="anchor" href="#3重复继承-虚基类">#</a> 3. 重复继承 ---- 虚基类</h4><ul><li><p>若直接基类有公共的基类，则会出现重复继承</p><p>例：</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A
&#123; int x;
......
&#125;;
class B: public A &#123; ... &#125;;
class C: public A &#123; ... &#125;;
class D: public B, public C &#123; ... &#125;;
&#x2F;&#x2F;上面的类D将包含两个x成员：B::x和C::x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li><li><p>虚基类</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class B: virtual public A &#123;...&#125;;
class C: virtual public A &#123;...&#125;;
class D: public B, public C &#123;...&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><p>对于包含虚基类的类：</p><ul><li>虚基类的构造函数由最新派生出的类的构造函数调用。</li><li>虚基类的构造函数优先非虚基类的构造函数执行。</li></ul></li></ul><h2 id="八-类属类型泛型-模板"><a class="anchor" href="#八-类属类型泛型-模板">#</a> 八、类属类型（泛型）---- 模板</h2><h3 id="一模板"><a class="anchor" href="#一模板">#</a> （一）模板</h3><p><img data-src="https://cdn.jsdelivr.net/gh/rainnn-w/Pictures@main/blog/202308281110912.png" alt="image-20230609202134205"></p><p><img data-src="https://cdn.jsdelivr.net/gh/rainnn-w/Pictures@main/blog/202308281110326.png" alt="image-20230609202353873"></p><h3 id="二c标准模板库stl"><a class="anchor" href="#二c标准模板库stl">#</a> （二）C++ 标准模板库（STL）</h3><hr><p>以下可忽略（）</p><h2 id="n-库函数"><a class="anchor" href="#n-库函数">#</a> N、库函数</h2><h3 id="1输入输出"><a class="anchor" href="#1输入输出">#</a> 1. 输入输出</h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iomanip&gt;
#include &lt;iostream&gt;
using namespace std;

int main()&#123;
    cout &lt;&lt; &quot;Hello, world!&quot;;  &#x2F;&#x2F;输出
	cout &lt;&lt; endl; &#x2F;&#x2F;换行
	cout &lt;&lt; &quot;Rainnn!&quot; &lt;&lt; endl;
    double root&#x3D;5.33333;
    cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; root;&#x2F;&#x2F;保留两位小数
    int i;
    double d;
    &#x2F;&#x2F;输入
    cin &gt;&gt; i;
    cin &gt;&gt; d;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ios::sync_with_stdio(false); &#x2F;&#x2F; 这两行能极大加速C++的输入性能。
cin.tie(nullptr);            &#x2F;&#x2F; 代价是不能混用scanf&#x2F;printf。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h3 id="2cmath"><a class="anchor" href="#2cmath">#</a> 2. <code>&lt;cmath&gt;</code></h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cmath&gt;
#include &lt;iostream&gt;
using namespace std;
int main()&#123;
    double count;
    count &#x3D; sqrt(double x); &#x2F;&#x2F;求平方根
    count &#x3D; pow(double x,double y); &#x2F;&#x2F;pow(底,指数的幂);
    
    &#x2F;&#x2F;三角函数
    count &#x3D; cos(double x); 
    count &#x3D; sin(double x);
    count &#x3D; tan(double x);
    count &#x3D; acos(double x);
    count &#x3D; asin(double x);
    count &#x3D; atan(double x);
    
    count &#x3D; log(double x); &#x2F;&#x2F;返回logex的值
    count &#x3D; log10(double x); &#x2F;&#x2F;返回log10x的值
    count &#x3D; exp(double x); &#x2F;&#x2F;返回指数函数e^x的值
    count &#x3D; exp2(double x); &#x2F;&#x2F;指数函数e^x的值
    
    count &#x3D; hypot(3.0,4.0); &#x2F;&#x2F;5.0 返回两个参数的平方总和的平方根,如果参数为一个直角三角形的两个直角边,函数会返回斜边的长度) 
    
    int c &#x3D; abs(int x); &#x2F;&#x2F;绝对值(只能填整数)
    count &#x3D; fabs(double x); &#x2F;&#x2F;绝对值（可以填小数）
    
    count &#x3D; floor(5.89); &#x2F;&#x2F;5 向下取整
    count &#x3D; ceil(5.89); &#x2F;&#x2F;6 向上取整
    
    count &#x3D; max(5.0,4.0); &#x2F;&#x2F;5.0 两者最大值
    count &#x3D; min(5.0,4.0); &#x2F;&#x2F;4.0 两者最小值
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="3bitset"><a class="anchor" href="#3bitset">#</a> 3. <code>&lt;bitset&gt;</code></h3><h4 id="1进制-oct-dec-hex"><a class="anchor" href="#1进制-oct-dec-hex">#</a> (1) 进制 oct dec hex</h4><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bitset&gt;
#include&lt;iostream&gt;
using namespace std;
int main()&#123;
    int a;
    cin &gt;&gt; hex &gt;&gt; a；&#x2F;&#x2F;输入16进制数
    cout &lt;&lt; dec &lt;&lt; a &lt;&lt; endl;&#x2F;&#x2F;转成10进制  
    cout &lt;&lt; oct &lt;&lt; 35&lt;&lt; endl; &#x2F;&#x2F;转成8进制
    cout &lt;&lt; dec &lt;&lt; 35 &lt;&lt; endl; &#x2F;&#x2F;转成10进制
    cout &lt;&lt; hex &lt;&lt; 35 &lt;&lt; endl; &#x2F;&#x2F;转成16进制
    cout &lt;&lt; bitset&lt;8&gt;(35) &lt;&lt; endl; &#x2F;&#x2F;2进制 &lt;8&gt;：表示保留8位输出
    return 0;  
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="4字符串"><a class="anchor" href="#4字符串">#</a> 4. 字符串</h3><h4 id="1基础-2"><a class="anchor" href="#1基础-2">#</a> (1) 基础</h4><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">1.类似于使用数组
string a &#x3D; “abcdef”;
int num &#x3D; a.length();
for (int i &#x3D; 0; i &lt; num; ++i)
&#123;
	cout &lt;&lt; a[i];
&#125;

2.使用for循环
string a &#x3D; “asdfa”;
for (char ch : a)&#123;
    cout &lt;&lt; ch;
&#125;
cout &lt;&lt; a.length();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h4 id="2-string"><a class="anchor" href="#2-string">#</a> (2) <code>&lt;string&gt;</code></h4><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;string&gt;
using namespace std;

int main()&#123;
    string s1, s2;
    getline(cin, s1);&#x2F;&#x2F;输入字符串
    getline(cin, s2);
    s1 +&#x3D; s2;&#x2F;&#x2F;字符串拼接
    s1.append(s2); &#x2F;&#x2F;把字符串s连接到当前字符串的结尾
    int num&#x3D;10;
    string to_string(num);&#x2F;&#x2F;将数字转换为字符串，这里注意如果是浮点型数转字符，会将精度范围内小数点后的数全部显示出来
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">1.int a &#x3D; str.find_first_of(&#39;abc&#39;); &#x2F;&#x2F; 获取字符串中第一个指定字符(串)的位置

2.int a &#x3D; str.find_last_of(&#39;.&#39;);&#x2F;&#x2F; 获取字符串中最后一个指定字符(串)的位置

3.string str1 &#x3D; str.substr(a,b);&#x2F;&#x2F; 根据以上两个端位置，保留第a位及之后共b个字符，（若b超出size则到最后）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">stoi函数: 将string类型转换成int类型的函数

stod函数: 将string类型转换成double类型的函数

atof函数: 将string类型转换成double类型的函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="5cctype"><a class="anchor" href="#5cctype">#</a> 5. <code>&lt;cctype&gt;</code></h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">1.isalpha()，用来判断一个字符是否为字母，如果是字符则返回非零，否则返回零。

2.isalnum()，用来判断一个字符是否为数字或者字母，也就是说判断一个字符是否属于a~z||A~Z||0~9。是返回非零，不是返回0。

3.islower()，用来判断一个字符是否为小写字母，也就是是否属于a~z。是返回非零，不是返回0。

4.isupper()，用来判断一个字符是否为大写字母。是返回非零，不是返回0。

if(isupper(str[i]))&#123;
   ...
&#125;

5.char c &#x3D; toupper(a)，a为字符时，如果a是小写字母则将其转换为大写字母，否则不变。a为数字则将其按ASCLL码转换为对应字符。（其实即使a是字符，输入之后还是会将其转换为int类型）

6.char c &#x3D; tolower(a)，a为字符时，如果a是大写字母则将其转换为小写字母，否则不变。a为数字则将其按ASCLL码转换为对应字符。

7.isdigit()，用来判断一个字符是否为数字，如果是数字则返回非零，否则返回零。
    
8.int isxdigit( int c )（判断字符c是否：16进制数字）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="6sstream"><a class="anchor" href="#6sstream">#</a> 6. <code>&lt;sstream&gt;</code></h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
using namespace std;

int main()&#123;
    istringstream iss;
    string s &#x3D; &quot;32 240 2 1450&quot;;
    iss.str(s);
    for (int n&#x3D;0; n&lt;4; n++)&#123;
    	int v;
    	iss &gt;&gt; v;
    	cout &lt;&lt; v &lt;&lt; endl;
  	&#125;
    cout &lt;&lt; &quot;Finished writing the numbers in: &quot;;
  	cout &lt;&lt; iss.str() &lt;&lt; endl;
&#125;
&#x2F;*
32
240
2
1450
Finished writing the numbers in: 32 240 2 1450
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;sstream&gt;
using namespace std;

int main()
&#123;
    int i &#x3D; 1000;
 
    ostringstream ss;
    ss &lt;&lt; hex &lt;&lt; i;
    string result &#x3D; ss.str();
 
    cout &lt;&lt; result &lt;&lt; endl;        &#x2F;&#x2F; 3e8
 
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="7iomanip"><a class="anchor" href="#7iomanip">#</a> 7. <code>&lt;iomanip&gt;</code></h3><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iomanip&gt;

cout &lt;&lt; setw(3) &lt;&lt; 1; &#x2F;&#x2F;按3列宽度输出(默认右对齐)
cout &lt;&lt; setw(3) &lt;&lt; left &lt;&lt; 1;&#x2F;&#x2F;左对齐
cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; root;&#x2F;&#x2F;保留两位小数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="8algorithm"><a class="anchor" href="#8algorithm">#</a> 8. <code>&lt;algorithm&gt;</code></h3><h4 id="1sort"><a class="anchor" href="#1sort">#</a> (1) <code>sort()</code></h4><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;

int main()&#123;
	int num[10] &#x3D; &#123;6,5,9,1,2,8,7,3,4,0&#125;;
	sort(num,num+10,greater&lt;int&gt;());
	for(int i&#x3D;0;i&lt;10;i++)&#123;
		cout&lt;&lt;num[i]&lt;&lt;&quot; &quot;;
	&#125;&#x2F;&#x2F;输出结果:9 8 7 6 5 4 3 2 1 0
	return 0;
&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>它有三个参数 <code>sort(begin, end, cmp)</code> ，其中 begin 为指向待 sort () 的数组的 <code>第一个元素的指针</code> ，end 为指向待 sort () 的数组的 <code>最后一个元素的下一个位置的指针</code> ，cmp 参数为排序准则，cmp 参数可以不写，如果不写的话，默认从小到大进行排序。如果我们想从大到小排序可以将 cmp 参数写为 <code>greater&lt;int&gt;()</code> 就是对 int 数组进行排序，当然 <code>&lt;&gt;</code> 中我们也可以写 double、long、float 等等。</p><ul><li><p>自定义排序准则</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;

bool cmp(int x,int y)&#123;
	return x % 10 &gt; y % 10;
&#125;

int main()&#123;
	int num[10] &#x3D; &#123;65,59,96,13,21,80,72,33,44,99&#125;;
	sort(num,num+10,cmp);
	for(int i&#x3D;0;i&lt;10;i++)&#123;
		cout&lt;&lt;num[i]&lt;&lt;&quot; &quot;;
	&#125;&#x2F;&#x2F;输出结果：59 99 96 65 44 13 33 72 21 80
	return 0;
&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>（也可以对结构体进行排序）</p><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
using namespace std;

struct Student&#123;
	string name;
	int score;
	Student() &#123;&#125;
	Student(string n,int s):name(n),score(s) &#123;&#125;
&#125;;

bool cmp_score(Student x,Student y)&#123;
	return x.score &gt; y.score;
&#125;

int main()&#123;
	Student stu[3];
	string n;
	int s;
	for(int i&#x3D;0;i&lt;3;i++)&#123;
		cin&gt;&gt;n&gt;&gt;s;
		stu[i] &#x3D; Student(n,s);
	&#125;
	sort(stu,stu+3,cmp_score);
	for(int i&#x3D;0;i&lt;3;i++)&#123;
		cout&lt;&lt;stu[i].name&lt;&lt;&quot; &quot;&lt;&lt;stu[i].score&lt;&lt;endl;
	&#125;
	return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li></ul><h3 id="9regex"><a class="anchor" href="#9regex">#</a> 9. <code>&lt;regex&gt;</code></h3><h4 id="1regex_match"><a class="anchor" href="#1regex_match">#</a> (1) <code>regex_match</code></h4><p>此函数模板用于匹配给定的模式。如果给定的表达式与字符串匹配，则此函数返回 <code>true</code> 。否则，该函数返回 <code>false</code> 。</p><h2 id="n1-算法"><a class="anchor" href="#n1-算法">#</a> N+1、算法</h2><h3 id="1排序"><a class="anchor" href="#1排序">#</a> 1. 排序</h3><h4 id="1冒泡排序"><a class="anchor" href="#1冒泡排序">#</a> （1）冒泡排序</h4><h4 id="2选择排序"><a class="anchor" href="#2选择排序">#</a> （2）选择排序</h4><p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
&#x2F;&#x2F;从大到小
int main()&#123;
    int max,temp;
    int n;
    cin &gt;&gt; n;
    int num[n];
    for(int i&#x3D;0;i&lt;n;i++)&#123;
        cin &gt;&gt; num[i];
    &#125;
    for(int index&#x3D;0;index&lt;n-1;index++)&#123;
        max&#x3D;index;
        for(int scan&#x3D;index+1;scan&lt;n;scan++)&#123;
            if(num[scan]&gt;num[max])&#123;
                max&#x3D;scan;
            &#125;
        &#125;
        temp&#x3D;num[index];
        num[index]&#x3D;num[max];
        num[max]&#x3D;temp;
    &#125;
&#125;
&#x2F;&#x2F;从小到大
void sort(string str[],int n)&#123;
    int min;
    string temp;
    for(int index&#x3D;0;index&lt;n-1;index++)&#123;
        min&#x3D;index;
        for(int scan&#x3D;index+1;scan&lt;n;scan++)&#123;
            if(str[scan].length()&lt;str[min].length())&#123;
                min&#x3D;scan;
            &#125;
        &#125;
        temp&#x3D;str[index];
        str[index]&#x3D;str[min];
        str[min]&#x3D;temp;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><div class="tags"><a href="/tags/c/" rel="tag"><i class="ic i-tag"></i> c++</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2023-08-28 11:10:45" itemprop="dateModified" datetime="2023-08-28T11:10:45+08:00">2023-08-28</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Rainnn-W WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="Rainnn-W Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="Rainnn-W PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>Rainnn-W <i class="ic i-at"><em>@</em></i>Rainnnの</li><li class="link"><strong>Post link: </strong><a href="https://rainnn-w.github.io/posts/20389.html" title="C++ Notes">https://rainnn-w.github.io/posts/20389.html</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/posts/14743.html" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicitf0kl1j20zk0m87fe.jpg" title="computing essentials"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i></span><h3>computing essentials</h3></a></div><div class="item right"><a href="/posts/43414.html" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipetlbztpj20zk0m84qp.jpg" title="课程学习及考试经验分享 （大一）"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i></span><h3>课程学习及考试经验分享 （大一）</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#c"><span class="toc-number">1.</span> <span class="toc-text">C++</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%B6-%E7%A2%8E"><span class="toc-number">1.1.</span> <span class="toc-text">零、碎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E9%80%89%E6%8B%A9-%E5%88%A4%E6%96%AD-%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">1.1.1.</span> <span class="toc-text">1. 选择 判断 知识点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E8%AF%BB%E7%A8%8B%E5%BA%8F-%E8%AE%A1%E7%AE%97"><span class="toc-number">1.1.2.</span> <span class="toc-text">2. 读程序 计算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E9%98%85%E8%AF%BB%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">指针阅读程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">派生类构造函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.</span> <span class="toc-text">一、概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80"><span class="toc-number">1.2.1.</span> <span class="toc-text">（一）程序设计语言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E4%BD%8E%E7%BA%A7%E8%AF%AD%E8%A8%80"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">1. 低级语言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">2. 高级语言</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8Cc%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E6%88%90"><span class="toc-number">1.2.2.</span> <span class="toc-text">（二）c++ 程序的构成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E8%AF%8D%E6%B3%95"><span class="toc-number">1.2.3.</span> <span class="toc-text">（三）词法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9Bcpp%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C"><span class="toc-number">1.2.4.</span> <span class="toc-text">（四）cpp 程序的运行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.5.</span> <span class="toc-text">（五）进制转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E5%8E%9F%E7%A0%81-%E5%8F%8D%E7%A0%81-%E8%A1%A5%E7%A0%81"><span class="toc-number">1.2.6.</span> <span class="toc-text">（六）原码 反码 补码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">二、基本数据类型和表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">（一）基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">1. 整数类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E5%AE%9E%E6%95%B0%E7%B1%BB%E5%9E%8B%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B%E9%BB%98%E8%AE%A4%E4%B8%BAdouble"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">2. 实数类型（浮点类型）默认为 double</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">3. 字符类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E9%80%BB%E8%BE%91%E7%B1%BB%E5%9E%8B-bool"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">4. 逻辑类型 bool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E7%A9%BA%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">5. 空值类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.3.2.</span> <span class="toc-text">（二）表现形式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%B8%B8%E9%87%8F"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">1. 常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">2. 变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.3.3.</span> <span class="toc-text">（三）操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E7%AE%97%E6%9C%AF%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">1. 算术操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E5%85%B3%E7%B3%BB%E4%B8%8E%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">2. 关系与逻辑操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.3.3.2.1.</span> <span class="toc-text">（1）关系操作符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.3.3.2.2.</span> <span class="toc-text">（2）逻辑操作符</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">3. 位操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E9%80%BB%E8%BE%91%E4%BD%8D%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.3.3.1.</span> <span class="toc-text">（1）逻辑位操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.3.3.2.</span> <span class="toc-text">（2）移位操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">4. 赋值运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.3.3.5.</span> <span class="toc-text">5. 其他操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E6%9D%A1%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.3.3.5.1.</span> <span class="toc-text">（1）条件操作符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E9%80%97%E5%8F%B7%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.3.3.5.2.</span> <span class="toc-text">（2）逗号操作符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3sizeof%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.3.3.5.3.</span> <span class="toc-text">（3）sizeof 操作符</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E6%93%8D%E4%BD%9C%E6%95%B0%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.3.3.6.</span> <span class="toc-text">6. 操作数的类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.3.3.6.1.</span> <span class="toc-text">（1）隐式类型转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E6%98%BE%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.3.3.6.2.</span> <span class="toc-text">（2）显式类型转换</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.4.</span> <span class="toc-text">三、控制语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E9%80%89%E6%8B%A9"><span class="toc-number">1.4.1.</span> <span class="toc-text">(一）选择</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1if"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">1.if</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2switch"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">2.switch</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.4.2.</span> <span class="toc-text">（二）循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1while"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">1.while</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2do-while"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">2.do-while</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3for"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">3.for</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%97%A0%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB"><span class="toc-number">1.4.3.</span> <span class="toc-text">（三）无条件转移</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1goto"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">1.goto</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2break"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">2.break</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3continue"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">3.continue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4return"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">4.return</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">四、函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="toc-number">1.5.1.</span> <span class="toc-text">1. 函数定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">1.5.2.</span> <span class="toc-text">2. 函数调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">1.5.3.</span> <span class="toc-text">3. 函数声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%B8%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">1.5.4.</span> <span class="toc-text">4. 局部变量与全局变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">（1）局部变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">（2）全局变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%A4%9A%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.5.</span> <span class="toc-text">5. 程序的多模块结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E6%A0%87%E8%AF%86%E7%AC%A6%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.5.6.</span> <span class="toc-text">6. 标识符的作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%B1%80%E9%83%A8%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.5.6.1.</span> <span class="toc-text">（1）局部作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.5.6.2.</span> <span class="toc-text">（2）全局作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E6%96%87%E4%BB%B6%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.5.6.3.</span> <span class="toc-text">（3）文件作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.5.6.4.</span> <span class="toc-text">（4）函数作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.5.6.5.</span> <span class="toc-text">（5）函数原型作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E5%90%8D%E7%A9%BA%E9%97%B4%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.5.6.6.</span> <span class="toc-text">（6）名空间作用域</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E5%8F%98%E9%87%8F%E7%9A%84%E7%94%9F%E5%AD%98%E6%9C%9F%E5%AD%98%E5%82%A8%E5%88%86%E9%85%8D"><span class="toc-number">1.5.7.</span> <span class="toc-text">7. 变量的生存期（存储分配）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">1.5.8.</span> <span class="toc-text">8. 宏定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.9.</span> <span class="toc-text">9. 内联函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E5%B8%A6%E9%BB%98%E8%AE%A4%E5%80%BC%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%8F%82%E6%95%B0"><span class="toc-number">1.5.10.</span> <span class="toc-text">10. 带默认值的形式参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E5%87%BD%E6%95%B0%E5%90%8D%E9%87%8D%E8%BD%BD"><span class="toc-number">1.5.11.</span> <span class="toc-text">11. 函数名重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%CE%BBlambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.5.12.</span> <span class="toc-text">12.λ（lambda）表达式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.</span> <span class="toc-text">五、构造数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E6%9E%9A%E4%B8%BE"><span class="toc-number">1.6.1.</span> <span class="toc-text">（一）枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">1. 枚举类型的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BF%90%E7%AE%97"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">2. 枚举类型的运算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E6%95%B0%E7%BB%84"><span class="toc-number">1.6.2.</span> <span class="toc-text">（二）数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">1. 一维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E5%AE%9A%E4%B9%89"><span class="toc-number">1.6.2.1.1.</span> <span class="toc-text">（1）定义：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.6.2.1.2.</span> <span class="toc-text">（2）变量的初始化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E4%B8%80%E7%BB%B4%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">2. 一维字符数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">3. 二维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E5%AE%9A%E4%B9%89-2"><span class="toc-number">1.6.2.3.1.</span> <span class="toc-text">（1）定义：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.6.2.3.2.</span> <span class="toc-text">（2）初始化：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.3.</span> <span class="toc-text">（三）结构类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%AE%9A%E4%B9%89-3"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">1. 定义：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E5%88%9D%E5%A7%8B%E5%8C%96-2"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">2. 初始化：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E8%AE%BF%E9%97%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-number">1.6.3.3.</span> <span class="toc-text">3. 访问结构的成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E7%BB%93%E6%9E%84%E6%95%B0%E6%8D%AE%E7%9A%84%E8%B5%8B%E5%80%BC"><span class="toc-number">1.6.3.4.</span> <span class="toc-text">4. 结构数据的赋值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.4.</span> <span class="toc-text">（四）联合类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%AE%9A%E4%B9%89-4"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">1. 定义：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.5.</span> <span class="toc-text">（五）指针类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.6.5.1.</span> <span class="toc-text">1. 指针类型的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E9%97%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9C"><span class="toc-number">1.6.5.1.1.</span> <span class="toc-text">（2）间接访问操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%90%E7%AE%97"><span class="toc-number">1.6.5.1.2.</span> <span class="toc-text">（3）指针的运算</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88%E5%8A%A0%E4%B8%8A%E6%88%96%E5%87%8F%E5%8E%BB%E4%B8%80%E4%B8%AA%E6%95%B4%E5%9E%8B%E5%80%BC"><span class="toc-number">1.6.5.1.2.1.</span> <span class="toc-text">①一个指针加上或减去一个整型值</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E4%B8%A4%E4%B8%AA%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%8C%87%E9%92%88%E7%9B%B8%E5%87%8F"><span class="toc-number">1.6.5.1.2.2.</span> <span class="toc-text">②两个同类型的指针相减</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3%E4%B8%A4%E4%B8%AA%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%8C%87%E9%92%88%E6%AF%94%E8%BE%83"><span class="toc-number">1.6.5.1.2.3.</span> <span class="toc-text">③两个同类型的指针比较</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E6%8C%87%E9%92%88%E7%9A%84%E8%BE%93%E5%87%BA"><span class="toc-number">1.6.5.1.3.</span> <span class="toc-text">（4）指针的输出</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.5.2.</span> <span class="toc-text">3. 指针作为参数类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E6%8F%90%E9%AB%98%E4%BC%A0%E5%8F%82%E6%95%88%E7%8E%87"><span class="toc-number">1.6.5.2.1.</span> <span class="toc-text">（1）提高传参效率</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E9%80%9A%E8%BF%87%E5%8F%82%E6%95%B0%E8%BF%94%E5%9B%9E%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C"><span class="toc-number">1.6.5.2.2.</span> <span class="toc-text">（2）通过参数返回函数的计算结果</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E6%8C%87%E5%90%91%E5%B8%B8%E9%87%8F%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">1.6.5.2.3.</span> <span class="toc-text">（3）指向常量的指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.5.2.4.</span> <span class="toc-text">（4）作为返回值类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E6%8C%87%E9%92%88%E4%B8%8E%E5%8A%A8%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">1.6.5.3.</span> <span class="toc-text">4. 指针与动态变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E5%8A%A8%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.6.5.3.1.</span> <span class="toc-text">（1）动态变量的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1new-%E7%B1%BB%E5%9E%8B%E5%90%8D"><span class="toc-number">1.6.5.3.1.1.</span> <span class="toc-text">① new &lt;类型名&gt;</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2new-%E7%B1%BB%E5%9E%8B%E5%90%8D"><span class="toc-number">1.6.5.3.1.2.</span> <span class="toc-text">② new &lt;类型名&gt; [][]</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3void-mallocunsigned-int-size"><span class="toc-number">1.6.5.3.1.3.</span> <span class="toc-text">③ void *malloc(unsigned int size)</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E5%8A%A8%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-number">1.6.5.3.2.</span> <span class="toc-text">（2）动态变量的访问</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E5%8A%A8%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E6%92%A4%E9%94%80"><span class="toc-number">1.6.5.3.3.</span> <span class="toc-text">（3）动态变量的撤销</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1delete-%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F"><span class="toc-number">1.6.5.3.3.1.</span> <span class="toc-text">① delete &lt;指针变量&gt;</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2delete-%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F"><span class="toc-number">1.6.5.3.3.2.</span> <span class="toc-text">② delete []&lt;指针变量&gt;</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3void-freevoid-p"><span class="toc-number">1.6.5.3.3.3.</span> <span class="toc-text">③ void free(void *p)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84"><span class="toc-number">1.6.5.4.</span> <span class="toc-text">5. 指针与数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E9%A6%96%E5%9C%B0%E5%9D%80"><span class="toc-number">1.6.5.4.1.</span> <span class="toc-text">（1）一维数组的首地址</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E9%80%9A%E8%BF%87%E6%95%B0%E7%BB%84%E9%A6%96%E5%85%83%E7%B4%A0%E6%9D%A5%E8%8E%B7%E5%BE%97"><span class="toc-number">1.6.5.4.1.1.</span> <span class="toc-text">①通过数组首元素来获得</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E9%80%9A%E8%BF%87%E6%95%B4%E4%B8%AA%E6%95%B0%E7%BB%84%E8%8E%B7%E5%BE%97"><span class="toc-number">1.6.5.4.1.2.</span> <span class="toc-text">②通过整个数组获得</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E9%A6%96%E5%9C%B0%E5%9D%80"><span class="toc-number">1.6.5.4.2.</span> <span class="toc-text">（2）多维数组的首地址</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E9%80%9A%E8%BF%87%E7%AC%AC%E4%B8%80%E8%A1%8C%E7%AC%AC%E4%B8%80%E5%88%97%E5%85%83%E7%B4%A0%E6%9D%A5%E8%8E%B7%E5%BE%97"><span class="toc-number">1.6.5.4.2.1.</span> <span class="toc-text">①通过第一行第一列元素来获得</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E9%80%9A%E8%BF%87%E7%AC%AC%E4%B8%80%E8%A1%8C%E7%9A%84%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9D%A5%E8%8E%B7%E5%BE%97"><span class="toc-number">1.6.5.4.2.2.</span> <span class="toc-text">②通过第一行的一维数组来获得</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3%E9%80%9A%E8%BF%87%E6%95%B4%E4%B8%AA%E6%95%B0%E7%BB%84%E6%9D%A5%E8%8E%B7%E5%BE%97"><span class="toc-number">1.6.5.4.2.3.</span> <span class="toc-text">③通过整个数组来获得</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E5%87%BD%E6%95%B0main%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">1.6.5.4.3.</span> <span class="toc-text">（3）函数 main 的参数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">1.6.5.5.</span> <span class="toc-text">6. 函数指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E5%A4%9A%E7%BA%A7%E6%8C%87%E9%92%88"><span class="toc-number">1.6.5.6.</span> <span class="toc-text">7. 多级指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AD%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%AB%E5%90%8D"><span class="toc-number">1.6.5.7.</span> <span class="toc-text">（六）引用类型（变量的别名）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%AE%9A%E4%B9%89-5"><span class="toc-number">1.6.5.8.</span> <span class="toc-text">1. 定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.5.9.</span> <span class="toc-text">2. 引用类型作为函数的参数类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB"><span class="toc-number">1.7.</span> <span class="toc-text">六、对象与类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.7.1.</span> <span class="toc-text">（一）面向对象程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%9F%BA%E7%A1%80"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">1. 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1"><span class="toc-number">1.7.1.1.1.</span> <span class="toc-text">（1）数据抽象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85"><span class="toc-number">1.7.1.1.2.</span> <span class="toc-text">（2）数据封装</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E6%A0%88"><span class="toc-number">1.7.1.1.3.</span> <span class="toc-text">（3）栈</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">2. 对象和类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E7%BB%A7%E6%89%BFinheritance"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">3. 继承 (Inheritance)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E5%A4%9A%E6%80%81%E4%B8%8E%E7%BB%91%E5%AE%9A"><span class="toc-number">1.7.1.4.</span> <span class="toc-text">4. 多态与绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E5%A4%9A%E6%80%81"><span class="toc-number">1.7.1.4.1.</span> <span class="toc-text">（1）多态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E7%BB%91%E5%AE%9A"><span class="toc-number">1.7.1.4.2.</span> <span class="toc-text">（2）绑定</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%B1%BB"><span class="toc-number">1.7.2.</span> <span class="toc-text">（二）类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">1. 数据成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">2. 成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-number">1.7.2.3.</span> <span class="toc-text">3. 成员的访问控制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.7.3.</span> <span class="toc-text">（三）对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">1. 对象的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E7%9B%B4%E6%8E%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.3.1.1.</span> <span class="toc-text">（1）直接方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E9%97%B4%E6%8E%A5%E6%96%B9%E5%BC%8F%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.7.3.1.2.</span> <span class="toc-text">（2）间接方式（动态对象）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">2. 对象的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3this%E6%8C%87%E9%92%88"><span class="toc-number">1.7.3.3.</span> <span class="toc-text">3. this 指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B6%88%E4%BA%A1%E5%89%8D%E5%A4%84%E7%90%86"><span class="toc-number">1.7.4.</span> <span class="toc-text">（四）对象的初始化和消亡前处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0constructors"><span class="toc-number">1.7.4.1.</span> <span class="toc-text">1. 构造函数 (Constructors)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E5%AE%9A%E4%B9%89-6"><span class="toc-number">1.7.4.1.1.</span> <span class="toc-text">（1）定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E8%B0%83%E7%94%A8"><span class="toc-number">1.7.4.1.2.</span> <span class="toc-text">（2）调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A1%A8"><span class="toc-number">1.7.4.1.3.</span> <span class="toc-text">（3）成员初始化表</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0destructors"><span class="toc-number">1.7.4.2.</span> <span class="toc-text">2. 析构函数 (Destructors)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E5%AF%B9%E6%AF%94"><span class="toc-number">1.7.4.3.</span> <span class="toc-text">总结对比</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7%E8%B4%A8"><span class="toc-number">1.7.4.3.1.</span> <span class="toc-text">构造函数的特殊性质</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7%E8%B4%A8"><span class="toc-number">1.7.4.3.2.</span> <span class="toc-text">析构函数的特殊性质</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E6%88%90%E5%91%98%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.7.4.4.</span> <span class="toc-text">3. 成员对象的初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.4.5.</span> <span class="toc-text">4. 拷贝构造函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94-%E8%BF%9B%E9%98%B6"><span class="toc-number">1.7.5.</span> <span class="toc-text">（五） 进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%B8%B8const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.5.1.</span> <span class="toc-text">1. 常 (const) 成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E5%B8%B8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.5.1.1.</span> <span class="toc-text">（1）常成员函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E5%B8%B8%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.7.5.1.2.</span> <span class="toc-text">（2）常对象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="toc-number">1.7.5.2.</span> <span class="toc-text">2. 静态数据成员</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="toc-number">1.7.5.2.1.</span> <span class="toc-text">（1）静态数据成员</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.5.2.2.</span> <span class="toc-text">（2）静态成员函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E5%8F%8B%E5%85%83friend"><span class="toc-number">1.7.5.3.</span> <span class="toc-text">3. 友元 (friend)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E8%BD%AC%E7%A7%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.5.4.</span> <span class="toc-text">4. 转移构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">1.7.5.5.</span> <span class="toc-text">5. 操作符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E6%A6%82%E8%BF%B0"><span class="toc-number">1.7.5.5.1.</span> <span class="toc-text">（1）概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E5%8F%8C%E7%9B%AE%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">1.7.5.5.2.</span> <span class="toc-text">（2）双目操作符重载</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E5%8D%95%E7%9B%AE%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">1.7.5.5.3.</span> <span class="toc-text">（3）单目操作符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%92%8C-%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">1.7.5.5.3.1.</span> <span class="toc-text">操作符 ++ 和 -- 的重载</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C%E7%AC%A6-%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">1.7.5.5.3.2.</span> <span class="toc-text">②访问数组元素操作符 “[]” 的重载</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3%E9%87%8D%E8%BD%BD%E6%93%8D%E4%BD%9C%E7%AC%A6new"><span class="toc-number">1.7.5.5.3.3.</span> <span class="toc-text">③重载操作符 new</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4%E9%87%8D%E8%BD%BD%E6%93%8D%E4%BD%9C%E7%AC%A6delete"><span class="toc-number">1.7.5.5.3.4.</span> <span class="toc-text">④重载操作符 delete</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.7.5.5.3.5.</span> <span class="toc-text">⑤函数调用操作符 “()”</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#6%E7%B1%BB%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9C%E7%AC%A6-%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">1.7.5.5.3.6.</span> <span class="toc-text">⑥类成员访问操作符 “-&gt;” 的重载</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#7%E5%B8%A6%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.5.5.3.7.</span> <span class="toc-text">⑦带一个参数的构造函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.7.5.5.3.8.</span> <span class="toc-text">⑧自定义类型转换</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-%E7%BB%A7%E6%89%BF%E7%B1%BB%E7%9A%84%E5%A4%8D%E7%94%A8-%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="toc-number">1.8.</span> <span class="toc-text">七、继承（类的复用）---- 派生类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E6%A6%82%E8%BF%B0"><span class="toc-number">1.8.1.</span> <span class="toc-text">（一）概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">1. 继承关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8D%95%E7%BB%A7%E6%89%BF"><span class="toc-number">1.8.2.</span> <span class="toc-text">（二）单继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%8D%95%E7%BB%A7%E6%89%BF%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">1. 单继承派生类的定义：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E8%AE%BF%E9%97%AE%E5%9F%BA%E7%B1%BB%E6%88%90%E5%91%98"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">2. 访问基类成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F"><span class="toc-number">1.8.2.3.</span> <span class="toc-text">3. 继承方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.8.2.4.</span> <span class="toc-text">4. 初始化和赋值操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.8.2.4.1.</span> <span class="toc-text">①初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E8%B5%8B%E5%80%BC"><span class="toc-number">1.8.2.4.2.</span> <span class="toc-text">②赋值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E8%81%9A%E9%9B%86"><span class="toc-number">1.8.2.4.3.</span> <span class="toc-text">③聚集</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E5%AD%90%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.8.2.4.4.</span> <span class="toc-text">④子类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%B6%88%E6%81%AF%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-number">1.8.3.</span> <span class="toc-text">（三）消息（成员函数调用）的动态绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">1. 静态绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">2. 动态绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">1.8.3.3.</span> <span class="toc-text">3. 纯虚函数和抽象类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B-%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">1.8.4.</span> <span class="toc-text">（四） 多继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%AE%9A%E4%B9%89-7"><span class="toc-number">1.8.4.1.</span> <span class="toc-text">1. 定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E5%91%BD%E5%90%8D%E5%86%B2%E7%AA%81"><span class="toc-number">1.8.4.2.</span> <span class="toc-text">2. 命名冲突</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E9%87%8D%E5%A4%8D%E7%BB%A7%E6%89%BF-%E8%99%9A%E5%9F%BA%E7%B1%BB"><span class="toc-number">1.8.4.3.</span> <span class="toc-text">3. 重复继承 ---- 虚基类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB-%E7%B1%BB%E5%B1%9E%E7%B1%BB%E5%9E%8B%E6%B3%9B%E5%9E%8B-%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.9.</span> <span class="toc-text">八、类属类型（泛型）---- 模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.9.1.</span> <span class="toc-text">（一）模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8Cc%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93stl"><span class="toc-number">1.9.2.</span> <span class="toc-text">（二）C++ 标准模板库（STL）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#n-%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-number">1.10.</span> <span class="toc-text">N、库函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">1.10.1.</span> <span class="toc-text">1. 输入输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2cmath"><span class="toc-number">1.10.2.</span> <span class="toc-text">2. &lt;cmath&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3bitset"><span class="toc-number">1.10.3.</span> <span class="toc-text">3. &lt;bitset&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E8%BF%9B%E5%88%B6-oct-dec-hex"><span class="toc-number">1.10.3.1.</span> <span class="toc-text">(1) 进制 oct dec hex</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.10.4.</span> <span class="toc-text">4. 字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%9F%BA%E7%A1%80-2"><span class="toc-number">1.10.4.1.</span> <span class="toc-text">(1) 基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-string"><span class="toc-number">1.10.4.2.</span> <span class="toc-text">(2) &lt;string&gt;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5cctype"><span class="toc-number">1.10.5.</span> <span class="toc-text">5. &lt;cctype&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6sstream"><span class="toc-number">1.10.6.</span> <span class="toc-text">6. &lt;sstream&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7iomanip"><span class="toc-number">1.10.7.</span> <span class="toc-text">7. &lt;iomanip&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8algorithm"><span class="toc-number">1.10.8.</span> <span class="toc-text">8. &lt;algorithm&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1sort"><span class="toc-number">1.10.8.1.</span> <span class="toc-text">(1) sort()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9regex"><span class="toc-number">1.10.9.</span> <span class="toc-text">9. &lt;regex&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1regex_match"><span class="toc-number">1.10.9.1.</span> <span class="toc-text">(1) regex_match</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#n1-%E7%AE%97%E6%B3%95"><span class="toc-number">1.11.</span> <span class="toc-text">N+1、算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E6%8E%92%E5%BA%8F"><span class="toc-number">1.11.1.</span> <span class="toc-text">1. 排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">1.11.1.1.</span> <span class="toc-text">（1）冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">1.11.1.2.</span> <span class="toc-text">（2）选择排序</span></a></li></ol></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Rainnn-W" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Rainnn-W</p><div class="description" itemprop="description">blingbling~</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">8</span> <span class="name">posts</span></a></div><div class="item tags"><a href="/tags/"><span class="count">5</span> <span class="name">tags</span></a></div></nav><div class="social"></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/posts/14743.html" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/posts/43414.html" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/posts/16107.html" title="Hello World">Hello World</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/posts/15691.html" title="Linux">Linux</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/posts/43414.html" title="课程学习及考试经验分享 （大一）">课程学习及考试经验分享 （大一）</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/posts/32775.html" title="(零基础)pycharm+服务器+anaconda虚拟环境|配置深度学习环境">(零基础)pycharm+服务器+anaconda虚拟环境|配置深度学习环境</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/posts/31528.html" title="Java Notes">Java Notes</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/posts/20389.html" title="C++ Notes">C++ Notes</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/posts/14743.html" title="computing essentials">computing essentials</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/posts/48639.html" title="使用Hexo+Github搭建个人博客">使用Hexo+Github搭建个人博客</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Rainnn-W @ Yume Shoka</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"posts/20389.html",favicon:{show:"（●´3｀●）Goooood",hide:"(´Д｀)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->